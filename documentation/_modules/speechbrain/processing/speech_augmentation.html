

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>speechbrain.processing.speech_augmentation &mdash; SpeechBrain 0.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> SpeechBrain
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Quick installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#install-via-pypi">Install via PyPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#install-locally">Install locally</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#test-installation">Test Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../experiment.html">Running an experiment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../experiment.html#yaml-basics">YAML basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../experiment.html#running-arguments">Running arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../experiment.html#tensor-format">Tensor format</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../multigpu.html">Basics of multi-GPU</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../multigpu.html#multi-gpu-training-using-data-parallel">Multi-GPU training using Data Parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../multigpu.html#multi-gpu-training-using-distributed-data-parallel-ddp">Multi-GPU training using Distributed Data Parallel (DDP)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../multigpu.html#with-multiple-machines-suppose-you-have-2-servers-with-2-gpus">With multiple machines (suppose you have 2 servers with 2 GPUs):</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#zen-of-speechbrain">Zen of Speechbrain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#how-to-get-your-code-in-speechbrain">How to get your code in SpeechBrain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#python">Python</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#version">Version</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#formatting">Formatting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#adding-dependencies">Adding dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#testing">Testing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#documentation">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#development-tools">Development tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#flake8">flake8</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#pre-commit">pre-commit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#the-git-pre-commit-hooks">the git pre-commit hooks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#the-git-pre-push-hooks">the git pre-push hooks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#pytest-doctests">pytest doctests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#continuous-integration">Continuous integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#what-is-ci">What is CI?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#ci-cd-pipelines">CI / CD Pipelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#our-test-suite">Our test suite</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#pull-request-review-guide">Pull Request review guide</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">API Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../speechbrain.html">Core library (speechbrain)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.core.html">speechbrain.core module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.core.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.core.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.yaml.html">speechbrain.yaml module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.alignment.html">speechbrain.alignment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.alignment.aligner.html">speechbrain.alignment.aligner module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.alignment.aligner.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.alignment.aligner.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.dataio.html">speechbrain.dataio</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.batch.html">speechbrain.dataio.batch module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.batch.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.batch.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.dataio.html">speechbrain.dataio.dataio module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataio.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataio.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.dataloader.html">speechbrain.dataio.dataloader module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataloader.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataloader.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.dataset.html">speechbrain.dataio.dataset module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataset.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataset.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.encoder.html">speechbrain.dataio.encoder module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.encoder.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.encoder.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.legacy.html">speechbrain.dataio.legacy module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.legacy.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.legacy.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.sampler.html">speechbrain.dataio.sampler module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.sampler.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.sampler.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.wer.html">speechbrain.dataio.wer module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.wer.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.wer.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.decoders.html">speechbrain.decoders</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.decoders.ctc.html">speechbrain.decoders.ctc module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.ctc.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.ctc.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.decoders.seq2seq.html">speechbrain.decoders.seq2seq module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.seq2seq.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.seq2seq.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.decoders.transducer.html">speechbrain.decoders.transducer module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.transducer.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.transducer.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.lm.html">speechbrain.lm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lm.arpa.html">speechbrain.lm.arpa module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.arpa.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.arpa.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lm.counting.html">speechbrain.lm.counting module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.counting.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.counting.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lm.ngram.html">speechbrain.lm.ngram module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.ngram.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.ngram.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.lobes.html">speechbrain.lobes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lobes.augment.html">speechbrain.lobes.augment module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.augment.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.augment.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lobes.features.html">speechbrain.lobes.features module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.features.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.features.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lobes.models.html">speechbrain.lobes.models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.CRDNN.html">speechbrain.lobes.models.CRDNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.ContextNet.html">speechbrain.lobes.models.ContextNet module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.ECAPA_TDNN.html">speechbrain.lobes.models.ECAPA_TDNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.ESPnetVGG.html">speechbrain.lobes.models.ESPnetVGG module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.MetricGAN_D.html">speechbrain.lobes.models.MetricGAN_D module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.RNNLM.html">speechbrain.lobes.models.RNNLM module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.VanillaNN.html">speechbrain.lobes.models.VanillaNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.Xvector.html">speechbrain.lobes.models.Xvector module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.conv_tasnet.html">speechbrain.lobes.models.conv_tasnet module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.convolution.html">speechbrain.lobes.models.convolution module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.dual_path.html">speechbrain.lobes.models.dual_path module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.transformer.html">speechbrain.lobes.models.transformer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.nnet.html">speechbrain.nnet</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.CNN.html">speechbrain.nnet.CNN module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.CNN.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.CNN.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.RNN.html">speechbrain.nnet.RNN module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.RNN.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.RNN.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.activations.html">speechbrain.nnet.activations module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.activations.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.activations.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.attention.html">speechbrain.nnet.attention module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.attention.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.attention.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.containers.html">speechbrain.nnet.containers module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.containers.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.containers.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.dropout.html">speechbrain.nnet.dropout module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.dropout.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.dropout.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.embedding.html">speechbrain.nnet.embedding module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.embedding.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.embedding.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.linear.html">speechbrain.nnet.linear module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.linear.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.linear.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.losses.html">speechbrain.nnet.losses module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.losses.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.losses.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.normalization.html">speechbrain.nnet.normalization module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.normalization.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.normalization.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.pooling.html">speechbrain.nnet.pooling module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.pooling.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.pooling.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.schedulers.html">speechbrain.nnet.schedulers module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.schedulers.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.schedulers.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.html">speechbrain.nnet.complex_networks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_CNN.html">speechbrain.nnet.complex_networks.c_CNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_RNN.html">speechbrain.nnet.complex_networks.c_RNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_linear.html">speechbrain.nnet.complex_networks.c_linear module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_normalization.html">speechbrain.nnet.complex_networks.c_normalization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_ops.html">speechbrain.nnet.complex_networks.c_ops module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.loss.html">speechbrain.nnet.loss</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.loss.stoi_loss.html">speechbrain.nnet.loss.stoi_loss module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.loss.transducer_loss.html">speechbrain.nnet.loss.transducer_loss module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.html">speechbrain.nnet.quaternion_networks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_CNN.html">speechbrain.nnet.quaternion_networks.q_CNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_RNN.html">speechbrain.nnet.quaternion_networks.q_RNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_linear.html">speechbrain.nnet.quaternion_networks.q_linear module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_normalization.html">speechbrain.nnet.quaternion_networks.q_normalization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_ops.html">speechbrain.nnet.quaternion_networks.q_ops module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.transducer.html">speechbrain.nnet.transducer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.transducer.transducer_joint.html">speechbrain.nnet.transducer.transducer_joint module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.processing.html">speechbrain.processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.NMF.html">speechbrain.processing.NMF module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.NMF.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.NMF.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.PLDA_LDA.html">speechbrain.processing.PLDA_LDA module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.PLDA_LDA.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.PLDA_LDA.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.decomposition.html">speechbrain.processing.decomposition module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.decomposition.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.decomposition.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.diarization.html">speechbrain.processing.diarization module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.diarization.html#reference">Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.diarization.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.diarization.html#id1">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.features.html">speechbrain.processing.features module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.features.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.features.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.multi_mic.html">speechbrain.processing.multi_mic module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.multi_mic.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.multi_mic.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.signal_processing.html">speechbrain.processing.signal_processing module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.signal_processing.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.signal_processing.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.speech_augmentation.html">speechbrain.processing.speech_augmentation module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.speech_augmentation.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.speech_augmentation.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.tokenizers.html">speechbrain.tokenizers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.tokenizers.SentencePiece.html">speechbrain.tokenizers.SentencePiece module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.tokenizers.SentencePiece.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.tokenizers.SentencePiece.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.utils.html">speechbrain.utils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.Accuracy.html">speechbrain.utils.Accuracy module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.Accuracy.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.Accuracy.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.DER.html">speechbrain.utils.DER module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.DER.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.DER.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.checkpoints.html">speechbrain.utils.checkpoints module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.checkpoints.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.checkpoints.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.convert_model.html">speechbrain.utils.convert_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.data_pipeline.html">speechbrain.utils.data_pipeline module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_pipeline.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_pipeline.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.data_utils.html">speechbrain.utils.data_utils module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_utils.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_utils.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.depgraph.html">speechbrain.utils.depgraph module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.depgraph.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.depgraph.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.distributed.html">speechbrain.utils.distributed module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.distributed.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.distributed.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.edit_distance.html">speechbrain.utils.edit_distance module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.edit_distance.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.edit_distance.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.epoch_loop.html">speechbrain.utils.epoch_loop module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.epoch_loop.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.epoch_loop.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.logger.html">speechbrain.utils.logger module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.logger.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.logger.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.metric_stats.html">speechbrain.utils.metric_stats module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.metric_stats.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.metric_stats.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.parameter_transfer.html">speechbrain.utils.parameter_transfer module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.parameter_transfer.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.parameter_transfer.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.superpowers.html">speechbrain.utils.superpowers module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.superpowers.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.superpowers.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.train_logger.html">speechbrain.utils.train_logger module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.train_logger.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.train_logger.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools.html">Runnable Tools (tools)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tools.compute_wer.html">tools.compute_wer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tools.compute_wer.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SpeechBrain</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>speechbrain.processing.speech_augmentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for speechbrain.processing.speech_augmentation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Classes for mutating speech data for data augmentation.</span>

<span class="sd">This module provides classes that produce realistic distortions of speech</span>
<span class="sd">data for the purpose of training speech processing models. The list of</span>
<span class="sd">distortions includes adding noise, adding reverberation, changing speed,</span>
<span class="sd">and more. All the classes are of type `torch.nn.Module`. This gives the</span>
<span class="sd">possibility to have end-to-end differentiability and</span>
<span class="sd">backpropagate the gradient through them. In addition, all operations</span>
<span class="sd">are expected to be performed on the GPU (where available) for efficiency.</span>

<span class="sd">Authors</span>
<span class="sd"> * Peter Plantinga 2020</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Importing libraries</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
<span class="kn">from</span> <span class="nn">speechbrain.dataio.legacy</span> <span class="k">import</span> <span class="n">ExtendedCSVDataset</span>
<span class="kn">from</span> <span class="nn">speechbrain.dataio.dataloader</span> <span class="k">import</span> <span class="n">make_dataloader</span>
<span class="kn">from</span> <span class="nn">speechbrain.processing.signal_processing</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">compute_amplitude</span><span class="p">,</span>
    <span class="n">dB_to_amplitude</span><span class="p">,</span>
    <span class="n">convolve1d</span><span class="p">,</span>
    <span class="n">notch_filter</span><span class="p">,</span>
    <span class="n">reverberate</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="AddNoise"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.AddNoise">[docs]</a><span class="k">class</span> <span class="nc">AddNoise</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class additively combines a noise signal to the input signal.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    csv_file : str</span>
<span class="sd">        The name of a csv file containing the location of the</span>
<span class="sd">        noise audio files. If none is provided, white noise will be used.</span>
<span class="sd">    csv_keys : list, None, optional</span>
<span class="sd">        Default: None . One data entry for the noise data should be specified.</span>
<span class="sd">        If None, the csv file is expected to have only one data entry.</span>
<span class="sd">    sorting : str</span>
<span class="sd">        The order to iterate the csv file, from one of the</span>
<span class="sd">        following options: random, original, ascending, and descending.</span>
<span class="sd">    num_workers : int</span>
<span class="sd">        Number of workers in the DataLoader (See PyTorch DataLoader docs).</span>
<span class="sd">    snr_low : int</span>
<span class="sd">        The low end of the mixing ratios, in decibels.</span>
<span class="sd">    snr_high : int</span>
<span class="sd">        The high end of the mixing ratios, in decibels.</span>
<span class="sd">    pad_noise : bool</span>
<span class="sd">        If True, copy noise signals that are shorter than</span>
<span class="sd">        their corresponding clean signals so as to cover the whole clean</span>
<span class="sd">        signal. Otherwise, leave the noise un-padded.</span>
<span class="sd">    mix_prob : float</span>
<span class="sd">        The probability that a batch of signals will be mixed</span>
<span class="sd">        with a noise signal. By default, every batch is mixed with noise.</span>
<span class="sd">    start_index : int</span>
<span class="sd">        The index in the noise waveforms to start from. By default, chooses</span>
<span class="sd">        a random index in [0, len(noise) - len(waveforms)].</span>
<span class="sd">    normalize : bool</span>
<span class="sd">        If True, output noisy signals that exceed [-1,1] will be</span>
<span class="sd">        normalized to [-1,1].</span>
<span class="sd">    replacements : dict</span>
<span class="sd">        A set of string replacements to carry out in the</span>
<span class="sd">        csv file. Each time a key is found in the text, it will be replaced</span>
<span class="sd">        with the corresponding value.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import pytest</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; signal = read_audio(&#39;samples/audio_samples/example1.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clean = signal.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; noisifier = AddNoise(&#39;samples/noise_samples/noise.csv&#39;)</span>
<span class="sd">    &gt;&gt;&gt; noisy = noisifier(clean, torch.ones(1))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">csv_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">csv_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sorting</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
        <span class="n">num_workers</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">snr_low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">snr_high</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">pad_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mix_prob</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">start_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">replacements</span><span class="o">=</span><span class="p">{},</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">csv_file</span> <span class="o">=</span> <span class="n">csv_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">csv_keys</span> <span class="o">=</span> <span class="n">csv_keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">=</span> <span class="n">sorting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span> <span class="o">=</span> <span class="n">num_workers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_low</span> <span class="o">=</span> <span class="n">snr_low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_high</span> <span class="o">=</span> <span class="n">snr_high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_noise</span> <span class="o">=</span> <span class="n">pad_noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mix_prob</span> <span class="o">=</span> <span class="n">mix_prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_index</span> <span class="o">=</span> <span class="n">start_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span> <span class="o">=</span> <span class="n">replacements</span>

<div class="viewcode-block" id="AddNoise.forward"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.AddNoise.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">,</span> <span class="n">lengths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        waveforms : tensor</span>
<span class="sd">            Shape should be `[batch, time]` or `[batch, time, channels]`.</span>
<span class="sd">        lengths : tensor</span>
<span class="sd">            Shape should be a single dimension, `[batch]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor of shape `[batch, time]` or `[batch, time, channels]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Copy clean waveform to initialize noisy waveform</span>
        <span class="n">noisy_waveform</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">(</span><span class="n">lengths</span> <span class="o">*</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Don&#39;t add noise (return early) 1-`mix_prob` portion of the batches</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mix_prob</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">noisy_waveform</span>

        <span class="c1"># Compute the average amplitude of the clean waveforms</span>
        <span class="n">clean_amplitude</span> <span class="o">=</span> <span class="n">compute_amplitude</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">lengths</span><span class="p">)</span>

        <span class="c1"># Pick an SNR and use it to compute the mixture amplitude factors</span>
        <span class="n">SNR</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">waveforms</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">SNR</span> <span class="o">=</span> <span class="n">SNR</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_high</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_low</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_low</span>
        <span class="n">noise_amplitude_factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dB_to_amplitude</span><span class="p">(</span><span class="n">SNR</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">new_noise_amplitude</span> <span class="o">=</span> <span class="n">noise_amplitude_factor</span> <span class="o">*</span> <span class="n">clean_amplitude</span>

        <span class="c1"># Scale clean signal appropriately</span>
        <span class="n">noisy_waveform</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">noise_amplitude_factor</span>

        <span class="c1"># Loop through clean samples and create mixture</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">csv_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">white_noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn_like</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span>
            <span class="n">noisy_waveform</span> <span class="o">+=</span> <span class="n">new_noise_amplitude</span> <span class="o">*</span> <span class="n">white_noise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tensor_length</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">noise_waveform</span><span class="p">,</span> <span class="n">noise_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_noise</span><span class="p">(</span>
                <span class="n">lengths</span><span class="p">,</span> <span class="n">tensor_length</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Rescale and add</span>
            <span class="n">noise_amplitude</span> <span class="o">=</span> <span class="n">compute_amplitude</span><span class="p">(</span><span class="n">noise_waveform</span><span class="p">,</span> <span class="n">noise_length</span><span class="p">)</span>
            <span class="n">noise_waveform</span> <span class="o">*=</span> <span class="n">new_noise_amplitude</span> <span class="o">/</span> <span class="p">(</span><span class="n">noise_amplitude</span> <span class="o">+</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">14</span><span class="p">)</span>
            <span class="n">noisy_waveform</span> <span class="o">+=</span> <span class="n">noise_waveform</span>

        <span class="c1"># Normalizing to prevent clipping</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">:</span>
            <span class="n">abs_max</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">noisy_waveform</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">noisy_waveform</span> <span class="o">=</span> <span class="n">noisy_waveform</span> <span class="o">/</span> <span class="n">abs_max</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">noisy_waveform</span></div>

    <span class="k">def</span> <span class="nf">_load_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">max_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load a batch of noises&quot;&quot;&quot;</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">lengths</span><span class="o">.</span><span class="n">long</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>

        <span class="c1"># Load a noise batch</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;data_loader&quot;</span><span class="p">):</span>
            <span class="c1"># Set parameters based on input</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">lengths</span><span class="o">.</span><span class="n">device</span>

            <span class="c1"># Create a data loader for the noise wavforms</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">csv_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">ExtendedCSVDataset</span><span class="p">(</span>
                    <span class="n">csvpath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">csv_file</span><span class="p">,</span>
                    <span class="n">output_keys</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">csv_keys</span><span class="p">,</span>
                    <span class="n">sorting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sorting</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">!=</span> <span class="s2">&quot;random&quot;</span>
                    <span class="k">else</span> <span class="s2">&quot;original&quot;</span><span class="p">,</span>
                    <span class="n">replacements</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span> <span class="o">=</span> <span class="n">make_dataloader</span><span class="p">(</span>
                    <span class="n">dataset</span><span class="p">,</span>
                    <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                    <span class="n">num_workers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_workers</span><span class="p">,</span>
                    <span class="n">shuffle</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">noise_data</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span><span class="p">)</span>

        <span class="c1"># Load noise to correct device</span>
        <span class="n">noise_batch</span><span class="p">,</span> <span class="n">noise_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_noise_batch_of_size</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">noise_batch</span> <span class="o">=</span> <span class="n">noise_batch</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">lengths</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">noise_len</span> <span class="o">=</span> <span class="n">noise_len</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">lengths</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Convert relative length to an index</span>
        <span class="n">noise_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">noise_len</span> <span class="o">*</span> <span class="n">noise_batch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

        <span class="c1"># Ensure shortest wav can cover speech signal</span>
        <span class="c1"># WARNING: THIS COULD BE SLOW IF THERE ARE VERY SHORT NOISES</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_noise</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">torch</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">noise_len</span> <span class="o">&lt;</span> <span class="n">lengths</span><span class="p">):</span>
                <span class="n">min_len</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">noise_len</span><span class="p">)</span>
                <span class="n">prepend</span> <span class="o">=</span> <span class="n">noise_batch</span><span class="p">[:,</span> <span class="p">:</span><span class="n">min_len</span><span class="p">]</span>
                <span class="n">noise_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">prepend</span><span class="p">,</span> <span class="n">noise_batch</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">noise_len</span> <span class="o">+=</span> <span class="n">min_len</span>

        <span class="c1"># Ensure noise batch is long enough</span>
        <span class="k">elif</span> <span class="n">noise_batch</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_length</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_length</span> <span class="o">-</span> <span class="n">noise_batch</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">noise_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">noise_batch</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span>

        <span class="c1"># Select a random starting location in the waveform</span>
        <span class="n">start_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_index</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">max_chop</span> <span class="o">=</span> <span class="p">(</span><span class="n">noise_len</span> <span class="o">-</span> <span class="n">lengths</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
                <span class="n">high</span><span class="o">=</span><span class="n">max_chop</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">device</span><span class="o">=</span><span class="n">lengths</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>

        <span class="c1"># Truncate noise_batch to max_length</span>
        <span class="n">noise_batch</span> <span class="o">=</span> <span class="n">noise_batch</span><span class="p">[:,</span> <span class="n">start_index</span> <span class="p">:</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">max_length</span><span class="p">]</span>
        <span class="n">noise_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">noise_len</span> <span class="o">-</span> <span class="n">start_index</span><span class="p">)</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">max</span><span class="o">=</span><span class="n">max_length</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">noise_batch</span><span class="p">,</span> <span class="n">noise_len</span>

    <span class="k">def</span> <span class="nf">_load_noise_batch_of_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenate noise batches, then chop to correct size&quot;&quot;&quot;</span>

        <span class="n">noise_batch</span><span class="p">,</span> <span class="n">noise_lens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_noise_batch</span><span class="p">()</span>

        <span class="c1"># Expand</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">noise_batch</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">batch_size</span><span class="p">:</span>
            <span class="n">added_noise</span><span class="p">,</span> <span class="n">added_lens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_noise_batch</span><span class="p">()</span>
            <span class="n">noise_batch</span><span class="p">,</span> <span class="n">noise_lens</span> <span class="o">=</span> <span class="n">AddNoise</span><span class="o">.</span><span class="n">_concat_batch</span><span class="p">(</span>
                <span class="n">noise_batch</span><span class="p">,</span> <span class="n">noise_lens</span><span class="p">,</span> <span class="n">added_noise</span><span class="p">,</span> <span class="n">added_lens</span>
            <span class="p">)</span>

        <span class="c1"># Contract</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">noise_batch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">batch_size</span><span class="p">:</span>
            <span class="n">noise_batch</span> <span class="o">=</span> <span class="n">noise_batch</span><span class="p">[:</span><span class="n">batch_size</span><span class="p">]</span>
            <span class="n">noise_lens</span> <span class="o">=</span> <span class="n">noise_lens</span><span class="p">[:</span><span class="n">batch_size</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">noise_batch</span><span class="p">,</span> <span class="n">noise_lens</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_concat_batch</span><span class="p">(</span><span class="n">noise_batch</span><span class="p">,</span> <span class="n">noise_lens</span><span class="p">,</span> <span class="n">added_noise</span><span class="p">,</span> <span class="n">added_lens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Concatenate two noise batches of potentially different lengths&quot;&quot;&quot;</span>

        <span class="c1"># pad shorter batch to correct length</span>
        <span class="n">noise_tensor_len</span> <span class="o">=</span> <span class="n">noise_batch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">added_tensor_len</span> <span class="o">=</span> <span class="n">added_noise</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">noise_tensor_len</span> <span class="o">-</span> <span class="n">added_tensor_len</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">noise_tensor_len</span> <span class="o">&gt;</span> <span class="n">added_tensor_len</span><span class="p">:</span>
            <span class="n">added_noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">added_noise</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
            <span class="n">added_lens</span> <span class="o">=</span> <span class="n">added_lens</span> <span class="o">*</span> <span class="n">added_tensor_len</span> <span class="o">/</span> <span class="n">noise_tensor_len</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">noise_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">noise_batch</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
            <span class="n">noise_lens</span> <span class="o">=</span> <span class="n">noise_lens</span> <span class="o">*</span> <span class="n">noise_tensor_len</span> <span class="o">/</span> <span class="n">added_tensor_len</span>

        <span class="n">noise_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">noise_batch</span><span class="p">,</span> <span class="n">added_noise</span><span class="p">))</span>
        <span class="n">noise_lens</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">noise_lens</span><span class="p">,</span> <span class="n">added_lens</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">noise_batch</span><span class="p">,</span> <span class="n">noise_lens</span>

    <span class="k">def</span> <span class="nf">_load_noise_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load a batch of noises, restarting iteration if necessary.&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Don&#39;t necessarily know the key</span>
            <span class="n">noises</span><span class="p">,</span> <span class="n">lens</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_data</span><span class="p">)</span><span class="o">.</span><span class="n">at_position</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_data</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span><span class="p">)</span>
            <span class="n">noises</span><span class="p">,</span> <span class="n">lens</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_data</span><span class="p">)</span><span class="o">.</span><span class="n">at_position</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">noises</span><span class="p">,</span> <span class="n">lens</span></div>


<div class="viewcode-block" id="AddReverb"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.AddReverb">[docs]</a><span class="k">class</span> <span class="nc">AddReverb</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class convolves an audio signal with an impulse response.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    csv_file : str</span>
<span class="sd">        The name of a csv file containing the location of the</span>
<span class="sd">        impulse response files.</span>
<span class="sd">    sorting : str</span>
<span class="sd">        The order to iterate the csv file, from one of</span>
<span class="sd">        the following options: random, original, ascending, and descending.</span>
<span class="sd">    reverb_prob : float</span>
<span class="sd">        The chance that the audio signal will be reverbed.</span>
<span class="sd">        By default, every batch is reverbed.</span>
<span class="sd">    rir_scale_factor: float</span>
<span class="sd">        It compresses or dilates the given impulse response.</span>
<span class="sd">        If 0 &lt; scale_factor &lt; 1, the impulse response is compressed</span>
<span class="sd">        (less reverb), while if scale_factor &gt; 1 it is dilated</span>
<span class="sd">        (more reverb).</span>
<span class="sd">    replacements : dict</span>
<span class="sd">        A set of string replacements to carry out in the</span>
<span class="sd">        csv file. Each time a key is found in the text, it will be replaced</span>
<span class="sd">        with the corresponding value.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import pytest</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; signal = read_audio(&#39;samples/audio_samples/example1.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clean = signal.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; reverb = AddReverb(&#39;samples/rir_samples/rirs.csv&#39;)</span>
<span class="sd">    &gt;&gt;&gt; reverbed = reverb(clean, torch.ones(1))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">csv_file</span><span class="p">,</span>
        <span class="n">sorting</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
        <span class="n">reverb_prob</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">rir_scale_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">replacements</span><span class="o">=</span><span class="p">{},</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">csv_file</span> <span class="o">=</span> <span class="n">csv_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">=</span> <span class="n">sorting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverb_prob</span> <span class="o">=</span> <span class="n">reverb_prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacements</span> <span class="o">=</span> <span class="n">replacements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rir_scale_factor</span> <span class="o">=</span> <span class="n">rir_scale_factor</span>

        <span class="c1"># Create a data loader for the RIR waveforms</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">ExtendedCSVDataset</span><span class="p">(</span>
            <span class="n">csvpath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">csv_file</span><span class="p">,</span>
            <span class="n">sorting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">!=</span> <span class="s2">&quot;random&quot;</span> <span class="k">else</span> <span class="s2">&quot;original&quot;</span><span class="p">,</span>
            <span class="n">replacements</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">replacements</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span> <span class="o">=</span> <span class="n">make_dataloader</span><span class="p">(</span>
            <span class="n">dataset</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sorting</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rir_data</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span><span class="p">)</span>

<div class="viewcode-block" id="AddReverb.forward"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.AddReverb.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">,</span> <span class="n">lengths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        waveforms : tensor</span>
<span class="sd">            Shape should be `[batch, time]` or `[batch, time, channels]`.</span>
<span class="sd">        lengths : tensor</span>
<span class="sd">            Shape should be a single dimension, `[batch]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor of shape `[batch, time]` or `[batch, time, channels]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Don&#39;t add reverb (return early) 1-`reverb_prob` portion of the time</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverb_prob</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="c1"># Add channels dimension if necessary</span>
        <span class="n">channel_added</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">waveforms</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">channel_added</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Convert length from ratio to number of indices</span>
        <span class="c1"># lengths = (lengths * waveforms.shape[1])[:, None, None]</span>

        <span class="c1"># Load and prepare RIR</span>
        <span class="n">rir_waveform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_rir</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span>

        <span class="c1"># Compress or dilate RIR</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rir_scale_factor</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rir_waveform</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
                <span class="n">rir_waveform</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">scale_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rir_scale_factor</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                <span class="n">align_corners</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">rir_waveform</span> <span class="o">=</span> <span class="n">rir_waveform</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">rev_waveform</span> <span class="o">=</span> <span class="n">reverberate</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">rir_waveform</span><span class="p">,</span> <span class="n">rescale_amp</span><span class="o">=</span><span class="s2">&quot;avg&quot;</span><span class="p">)</span>

        <span class="c1"># Remove channels dimension if added</span>
        <span class="k">if</span> <span class="n">channel_added</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rev_waveform</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rev_waveform</span></div>

    <span class="k">def</span> <span class="nf">_load_rir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rir_waveform</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rir_data</span><span class="p">)</span><span class="o">.</span><span class="n">at_position</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rir_data</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span><span class="p">)</span>
            <span class="n">rir_waveform</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rir_data</span><span class="p">)</span><span class="o">.</span><span class="n">at_position</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Make sure RIR has correct channels</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rir_waveform</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">rir_waveform</span> <span class="o">=</span> <span class="n">rir_waveform</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Make sure RIR has correct type and device</span>
        <span class="n">rir_waveform</span> <span class="o">=</span> <span class="n">rir_waveform</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rir_waveform</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpeedPerturb"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.SpeedPerturb">[docs]</a><span class="k">class</span> <span class="nc">SpeedPerturb</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Slightly speed up or slow down an audio signal.</span>

<span class="sd">    Resample the audio signal at a rate that is similar to the original rate,</span>
<span class="sd">    to achieve a slightly slower or slightly faster signal. This technique is</span>
<span class="sd">    outlined in the paper: &quot;Audio Augmentation for Speech Recognition&quot;</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    orig_freq : int</span>
<span class="sd">        The frequency of the original signal.</span>
<span class="sd">    speeds : list</span>
<span class="sd">        The speeds that the signal should be changed to, as a percentage of the</span>
<span class="sd">        original signal (i.e. `speeds` is divided by 100 to get a ratio).</span>
<span class="sd">    perturb_prob : float</span>
<span class="sd">        The chance that the batch will be speed-</span>
<span class="sd">        perturbed. By default, every batch is perturbed.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; signal = read_audio(&#39;samples/audio_samples/example1.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; perturbator = SpeedPerturb(orig_freq=16000, speeds=[90])</span>
<span class="sd">    &gt;&gt;&gt; clean = signal.unsqueeze(0)</span>
<span class="sd">    &gt;&gt;&gt; perturbed = perturbator(clean)</span>
<span class="sd">    &gt;&gt;&gt; clean.shape</span>
<span class="sd">    torch.Size([1, 52173])</span>
<span class="sd">    &gt;&gt;&gt; perturbed.shape</span>
<span class="sd">    torch.Size([1, 46956])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">orig_freq</span><span class="p">,</span> <span class="n">speeds</span><span class="o">=</span><span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">],</span> <span class="n">perturb_prob</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span> <span class="o">=</span> <span class="n">orig_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speeds</span> <span class="o">=</span> <span class="n">speeds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perturb_prob</span> <span class="o">=</span> <span class="n">perturb_prob</span>

        <span class="c1"># Initialize index of perturbation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samp_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Initialize resamplers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resamplers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">speed</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">speeds</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;orig_freq&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span><span class="p">,</span>
                <span class="s2">&quot;new_freq&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span> <span class="o">*</span> <span class="n">speed</span> <span class="o">//</span> <span class="mi">100</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resamplers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Resample</span><span class="p">(</span><span class="o">**</span><span class="n">config</span><span class="p">))</span>

<div class="viewcode-block" id="SpeedPerturb.forward"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.SpeedPerturb.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        waveforms : tensor</span>
<span class="sd">            Shape should be `[batch, time]` or `[batch, time, channels]`.</span>
<span class="sd">        lengths : tensor</span>
<span class="sd">            Shape should be a single dimension, `[batch]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor of shape `[batch, time]` or `[batch, time, channels]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Don&#39;t perturb (return early) 1-`perturb_prob` portion of the batches</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">perturb_prob</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">waveform</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="c1"># Perform a random perturbation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samp_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speeds</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">perturbed_waveform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resamplers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">samp_index</span><span class="p">](</span><span class="n">waveform</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">perturbed_waveform</span></div></div>


<div class="viewcode-block" id="Resample"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.Resample">[docs]</a><span class="k">class</span> <span class="nc">Resample</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class resamples an audio signal using sinc-based interpolation.</span>

<span class="sd">    It is a modification of the `resample` function from torchaudio</span>
<span class="sd">    (https://pytorch.org/audio/transforms.html#resample)</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    orig_freq : int</span>
<span class="sd">        the sampling frequency of the input signal.</span>
<span class="sd">    new_freq : int</span>
<span class="sd">        the new sampling frequency after this operation is performed.</span>
<span class="sd">    lowpass_filter_width : int</span>
<span class="sd">        Controls the sharpness of the filter, larger numbers result in a</span>
<span class="sd">        sharper filter, but they are less efficient. Values from 4 to 10 are</span>
<span class="sd">        allowed.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; signal = read_audio(&#39;samples/audio_samples/example1.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; signal = signal.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; resampler = Resample(orig_freq=16000, new_freq=8000)</span>
<span class="sd">    &gt;&gt;&gt; resampled = resampler(signal)</span>
<span class="sd">    &gt;&gt;&gt; signal.shape</span>
<span class="sd">    torch.Size([1, 52173])</span>
<span class="sd">    &gt;&gt;&gt; resampled.shape</span>
<span class="sd">    torch.Size([1, 26087])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">orig_freq</span><span class="o">=</span><span class="mi">16000</span><span class="p">,</span> <span class="n">new_freq</span><span class="o">=</span><span class="mi">16000</span><span class="p">,</span> <span class="n">lowpass_filter_width</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span> <span class="o">=</span> <span class="n">orig_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_freq</span> <span class="o">=</span> <span class="n">new_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowpass_filter_width</span> <span class="o">=</span> <span class="n">lowpass_filter_width</span>

        <span class="c1"># Compute rate for striding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_strides</span><span class="p">()</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_stride</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_freq</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_transpose_stride</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_compute_strides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the phases in polyphase filter.</span>

<span class="sd">        (almost directly from torchaudio.compliance.kaldi)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute new unit based on ratio of in/out frequencies</span>
        <span class="n">base_freq</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_freq</span><span class="p">)</span>
        <span class="n">input_samples_in_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span> <span class="o">//</span> <span class="n">base_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_freq</span> <span class="o">//</span> <span class="n">base_freq</span>

        <span class="c1"># Store the appropriate stride based on the new units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_stride</span> <span class="o">=</span> <span class="n">input_samples_in_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_transpose_stride</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_samples</span>

<div class="viewcode-block" id="Resample.forward"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.Resample.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        waveforms : tensor</span>
<span class="sd">            Shape should be `[batch, time]` or `[batch, time, channels]`.</span>
<span class="sd">        lengths : tensor</span>
<span class="sd">            Shape should be a single dimension, `[batch]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor of shape `[batch, time]` or `[batch, time, channels]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;first_indices&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices_and_weights</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span>

        <span class="c1"># Don&#39;t do anything if the frequencies are the same</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_freq</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">waveforms</span>

        <span class="n">unsqueezed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">waveforms</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">unsqueezed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">waveforms</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input must be 2 or 3 dimensions&quot;</span><span class="p">)</span>

        <span class="c1"># Do resampling</span>
        <span class="n">resampled_waveform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_perform_resample</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unsqueezed</span><span class="p">:</span>
            <span class="n">resampled_waveform</span> <span class="o">=</span> <span class="n">resampled_waveform</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resampled_waveform</span> <span class="o">=</span> <span class="n">resampled_waveform</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">resampled_waveform</span></div>

    <span class="k">def</span> <span class="nf">_perform_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resamples the waveform at the new frequency.</span>

<span class="sd">        This matches Kaldi&#39;s OfflineFeatureTpl ResampleWaveform which uses a</span>
<span class="sd">        LinearResample (resample a signal at linearly spaced intervals to</span>
<span class="sd">        up/downsample a signal). LinearResample (LR) means that the output</span>
<span class="sd">        signal is at linearly spaced intervals (i.e the output signal has a</span>
<span class="sd">        frequency of `new_freq`). It uses sinc/bandlimited interpolation to</span>
<span class="sd">        upsample/downsample the signal.</span>

<span class="sd">        (almost directly from torchaudio.compliance.kaldi)</span>

<span class="sd">        https://ccrma.stanford.edu/~jos/resample/</span>
<span class="sd">        Theory_Ideal_Bandlimited_Interpolation.html</span>

<span class="sd">        https://github.com/kaldi-asr/kaldi/blob/master/src/feat/resample.h#L56</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        waveforms : tensor</span>
<span class="sd">            The batch of audio signals to resample.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The waveforms at the new frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute output size and initialize</span>
        <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_channels</span><span class="p">,</span> <span class="n">wave_len</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">window_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tot_output_samp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_output_samples</span><span class="p">(</span><span class="n">wave_len</span><span class="p">)</span>
        <span class="n">resampled_waveform</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_channels</span><span class="p">,</span> <span class="n">tot_output_samp</span><span class="p">),</span>
            <span class="n">device</span><span class="o">=</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># Check weights are on correct device</span>
        <span class="k">if</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">device</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">device</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># eye size: (num_channels, num_channels, 1)</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Iterate over the phases in the polyphase filter</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_indices</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
            <span class="n">wave_to_conv</span> <span class="o">=</span> <span class="n">waveforms</span>
            <span class="n">first_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">first_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># trim the signal as the filter will not be applied</span>
                <span class="c1"># before the first_index</span>
                <span class="n">wave_to_conv</span> <span class="o">=</span> <span class="n">wave_to_conv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">first_index</span><span class="p">:]</span>

            <span class="c1"># pad the right of the signal to allow partial convolutions</span>
            <span class="c1"># meaning compute values for partial windows (e.g. end of the</span>
            <span class="c1"># window is outside the signal length)</span>
            <span class="n">max_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">tot_output_samp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_samples</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="n">max_index</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_stride</span> <span class="o">+</span> <span class="n">window_size</span>
            <span class="n">current_wave_len</span> <span class="o">=</span> <span class="n">wave_len</span> <span class="o">-</span> <span class="n">first_index</span>
            <span class="n">right_padding</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">current_wave_len</span><span class="p">)</span>
            <span class="n">left_padding</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">first_index</span><span class="p">)</span>
            <span class="n">wave_to_conv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">wave_to_conv</span><span class="p">,</span> <span class="p">(</span><span class="n">left_padding</span><span class="p">,</span> <span class="n">right_padding</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">conv_wave</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv1d</span><span class="p">(</span>
                <span class="nb">input</span><span class="o">=</span><span class="n">wave_to_conv</span><span class="p">,</span>
                <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">conv_stride</span><span class="p">,</span>
                <span class="n">groups</span><span class="o">=</span><span class="n">num_channels</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># we want conv_wave[:, i] to be at</span>
            <span class="c1"># output[:, i + n*conv_transpose_stride]</span>
            <span class="n">dilated_conv_wave</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">conv_transpose1d</span><span class="p">(</span>
                <span class="n">conv_wave</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">conv_transpose_stride</span>
            <span class="p">)</span>

            <span class="c1"># pad dilated_conv_wave so it reaches the output length if needed.</span>
            <span class="n">left_padding</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">previous_padding</span> <span class="o">=</span> <span class="n">left_padding</span> <span class="o">+</span> <span class="n">dilated_conv_wave</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">right_padding</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tot_output_samp</span> <span class="o">-</span> <span class="n">previous_padding</span><span class="p">)</span>
            <span class="n">dilated_conv_wave</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">dilated_conv_wave</span><span class="p">,</span> <span class="p">(</span><span class="n">left_padding</span><span class="p">,</span> <span class="n">right_padding</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">dilated_conv_wave</span> <span class="o">=</span> <span class="n">dilated_conv_wave</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">tot_output_samp</span><span class="p">]</span>

            <span class="n">resampled_waveform</span> <span class="o">+=</span> <span class="n">dilated_conv_wave</span>

        <span class="k">return</span> <span class="n">resampled_waveform</span>

    <span class="k">def</span> <span class="nf">_output_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_num_samp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Based on LinearResample::GetNumOutputSamples.</span>

<span class="sd">        LinearResample (LR) means that the output signal is at</span>
<span class="sd">        linearly spaced intervals (i.e the output signal has a</span>
<span class="sd">        frequency of ``new_freq``). It uses sinc/bandlimited</span>
<span class="sd">        interpolation to upsample/downsample the signal.</span>

<span class="sd">        (almost directly from torchaudio.compliance.kaldi)</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        input_num_samp : int</span>
<span class="sd">            The number of samples in each example in the batch.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Number of samples in the output waveform.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For exact computation, we measure time in &quot;ticks&quot; of 1.0 / tick_freq,</span>
        <span class="c1"># where tick_freq is the least common multiple of samp_in and</span>
        <span class="c1"># samp_out.</span>
        <span class="n">samp_in</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span><span class="p">)</span>
        <span class="n">samp_out</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">new_freq</span><span class="p">)</span>

        <span class="n">tick_freq</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">samp_in</span> <span class="o">*</span> <span class="n">samp_out</span><span class="p">)</span> <span class="o">//</span> <span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">samp_in</span><span class="p">,</span> <span class="n">samp_out</span><span class="p">)</span>
        <span class="n">ticks_per_input_period</span> <span class="o">=</span> <span class="n">tick_freq</span> <span class="o">//</span> <span class="n">samp_in</span>

        <span class="c1"># work out the number of ticks in the time interval</span>
        <span class="c1"># [ 0, input_num_samp/samp_in ).</span>
        <span class="n">interval_length</span> <span class="o">=</span> <span class="n">input_num_samp</span> <span class="o">*</span> <span class="n">ticks_per_input_period</span>
        <span class="k">if</span> <span class="n">interval_length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">ticks_per_output_period</span> <span class="o">=</span> <span class="n">tick_freq</span> <span class="o">//</span> <span class="n">samp_out</span>

        <span class="c1"># Get the last output-sample in the closed interval,</span>
        <span class="c1"># i.e. replacing [ ) with [ ]. Note: integer division rounds down.</span>
        <span class="c1"># See http://en.wikipedia.org/wiki/Interval_(mathematics) for an</span>
        <span class="c1"># explanation of the notation.</span>
        <span class="n">last_output_samp</span> <span class="o">=</span> <span class="n">interval_length</span> <span class="o">//</span> <span class="n">ticks_per_output_period</span>

        <span class="c1"># We need the last output-sample in the open interval, so if it</span>
        <span class="c1"># takes us to the end of the interval exactly, subtract one.</span>
        <span class="k">if</span> <span class="n">last_output_samp</span> <span class="o">*</span> <span class="n">ticks_per_output_period</span> <span class="o">==</span> <span class="n">interval_length</span><span class="p">:</span>
            <span class="n">last_output_samp</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># First output-sample index is zero, so the number of output samples</span>
        <span class="c1"># is the last output-sample plus one.</span>
        <span class="n">num_output_samp</span> <span class="o">=</span> <span class="n">last_output_samp</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">num_output_samp</span>

    <span class="k">def</span> <span class="nf">_indices_and_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Based on LinearResample::SetIndexesAndWeights</span>

<span class="sd">        Retrieves the weights for resampling as well as the indices in which</span>
<span class="sd">        they are valid. LinearResample (LR) means that the output signal is at</span>
<span class="sd">        linearly spaced intervals (i.e the output signal has a frequency</span>
<span class="sd">        of ``new_freq``). It uses sinc/bandlimited interpolation to</span>
<span class="sd">        upsample/downsample the signal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        - the place where each filter should start being applied</span>
<span class="sd">        - the filters to be applied to the signal for resampling</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Lowpass filter frequency depends on smaller of two frequencies</span>
        <span class="n">min_freq</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_freq</span><span class="p">)</span>
        <span class="n">lowpass_cutoff</span> <span class="o">=</span> <span class="mf">0.99</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">min_freq</span>

        <span class="k">assert</span> <span class="n">lowpass_cutoff</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">min_freq</span>
        <span class="n">window_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowpass_filter_width</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">lowpass_cutoff</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">lowpass_cutoff</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_freq</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">output_t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_samples</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output_t</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_freq</span>
        <span class="n">min_t</span> <span class="o">=</span> <span class="n">output_t</span> <span class="o">-</span> <span class="n">window_width</span>
        <span class="n">max_t</span> <span class="o">=</span> <span class="n">output_t</span> <span class="o">+</span> <span class="n">window_width</span>

        <span class="n">min_input_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span><span class="p">)</span>
        <span class="n">max_input_index</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">max_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span><span class="p">)</span>
        <span class="n">num_indices</span> <span class="o">=</span> <span class="n">max_input_index</span> <span class="o">-</span> <span class="n">min_input_index</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">max_weight_width</span> <span class="o">=</span> <span class="n">num_indices</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_weight_width</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">input_index</span> <span class="o">=</span> <span class="n">min_input_index</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">delta_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_index</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span><span class="p">)</span> <span class="o">-</span> <span class="n">output_t</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">delta_t</span><span class="p">)</span>
        <span class="n">inside_window_indices</span> <span class="o">=</span> <span class="n">delta_t</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">window_width</span><span class="p">)</span>

        <span class="c1"># raised-cosine (Hanning) window with width `window_width`</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">inside_window_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
            <span class="mi">1</span>
            <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span>
                <span class="mi">2</span>
                <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                <span class="o">*</span> <span class="n">lowpass_cutoff</span>
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowpass_filter_width</span>
                <span class="o">*</span> <span class="n">delta_t</span><span class="p">[</span><span class="n">inside_window_indices</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">t_eq_zero_indices</span> <span class="o">=</span> <span class="n">delta_t</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">t_not_eq_zero_indices</span> <span class="o">=</span> <span class="o">~</span><span class="n">t_eq_zero_indices</span>

        <span class="c1"># sinc filter function</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">t_not_eq_zero_indices</span><span class="p">]</span> <span class="o">*=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">lowpass_cutoff</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">[</span><span class="n">t_not_eq_zero_indices</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">[</span><span class="n">t_not_eq_zero_indices</span><span class="p">])</span>

        <span class="c1"># limit of the function at t = 0</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">t_eq_zero_indices</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lowpass_cutoff</span>

        <span class="c1"># size (output_samples, max_weight_width)</span>
        <span class="n">weights</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_freq</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first_indices</span> <span class="o">=</span> <span class="n">min_input_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="AddBabble"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.AddBabble">[docs]</a><span class="k">class</span> <span class="nc">AddBabble</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulate babble noise by mixing the signals in a batch.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    speaker_count : int</span>
<span class="sd">        The number of signals to mix with the original signal.</span>
<span class="sd">    snr_low : int</span>
<span class="sd">        The low end of the mixing ratios, in decibels.</span>
<span class="sd">    snr_high : int</span>
<span class="sd">        The high end of the mixing ratios, in decibels.</span>
<span class="sd">    mix_prob : float</span>
<span class="sd">        The probability that the batch of signals will be</span>
<span class="sd">        mixed with babble noise. By default, every signal is mixed.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import pytest</span>
<span class="sd">    &gt;&gt;&gt; babbler = AddBabble()</span>
<span class="sd">    &gt;&gt;&gt; dataset = ExtendedCSVDataset(</span>
<span class="sd">    ...     csvpath=&#39;samples/audio_samples/csv_example3.csv&#39;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; loader = make_dataloader(dataset, batch_size=5)</span>
<span class="sd">    &gt;&gt;&gt; speech, lengths = next(iter(loader)).at_position(0)</span>
<span class="sd">    &gt;&gt;&gt; noisy = babbler(speech, lengths)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">speaker_count</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">snr_low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">snr_high</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mix_prob</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speaker_count</span> <span class="o">=</span> <span class="n">speaker_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_low</span> <span class="o">=</span> <span class="n">snr_low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_high</span> <span class="o">=</span> <span class="n">snr_high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mix_prob</span> <span class="o">=</span> <span class="n">mix_prob</span>

<div class="viewcode-block" id="AddBabble.forward"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.AddBabble.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">,</span> <span class="n">lengths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        waveforms : tensor</span>
<span class="sd">            A batch of audio signals to process, with shape `[batch, time]` or</span>
<span class="sd">            `[batch, time, channels]`.</span>
<span class="sd">        lengths : tensor</span>
<span class="sd">            The length of each audio in the batch, with shape `[batch]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor with processed waveforms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">babbled_waveform</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">(</span><span class="n">lengths</span> <span class="o">*</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">waveforms</span><span class="p">)</span>

        <span class="c1"># Don&#39;t mix (return early) 1-`mix_prob` portion of the batches</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mix_prob</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">babbled_waveform</span>

        <span class="c1"># Pick an SNR and use it to compute the mixture amplitude factors</span>
        <span class="n">clean_amplitude</span> <span class="o">=</span> <span class="n">compute_amplitude</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">lengths</span><span class="p">)</span>
        <span class="n">SNR</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">SNR</span> <span class="o">=</span> <span class="n">SNR</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_high</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_low</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_low</span>
        <span class="n">noise_amplitude_factor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dB_to_amplitude</span><span class="p">(</span><span class="n">SNR</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">new_noise_amplitude</span> <span class="o">=</span> <span class="n">noise_amplitude_factor</span> <span class="o">*</span> <span class="n">clean_amplitude</span>

        <span class="c1"># Scale clean signal appropriately</span>
        <span class="n">babbled_waveform</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">noise_amplitude_factor</span>

        <span class="c1"># For each speaker in the mixture, roll and add</span>
        <span class="n">babble_waveform</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">roll</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dims</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">babble_len</span> <span class="o">=</span> <span class="n">lengths</span><span class="o">.</span><span class="n">roll</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dims</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">speaker_count</span><span class="p">):</span>
            <span class="n">babble_waveform</span> <span class="o">+=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">roll</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">,),</span> <span class="n">dims</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">babble_len</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">babble_len</span><span class="p">,</span> <span class="n">babble_len</span><span class="o">.</span><span class="n">roll</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dims</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Rescale and add to mixture</span>
        <span class="n">babble_amplitude</span> <span class="o">=</span> <span class="n">compute_amplitude</span><span class="p">(</span><span class="n">babble_waveform</span><span class="p">,</span> <span class="n">babble_len</span><span class="p">)</span>
        <span class="n">babble_waveform</span> <span class="o">*=</span> <span class="n">new_noise_amplitude</span> <span class="o">/</span> <span class="p">(</span><span class="n">babble_amplitude</span> <span class="o">+</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">14</span><span class="p">)</span>
        <span class="n">babbled_waveform</span> <span class="o">+=</span> <span class="n">babble_waveform</span>

        <span class="k">return</span> <span class="n">babbled_waveform</span></div></div>


<div class="viewcode-block" id="DropFreq"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.DropFreq">[docs]</a><span class="k">class</span> <span class="nc">DropFreq</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class drops a random frequency from the signal.</span>

<span class="sd">    The purpose of this class is to teach models to learn to rely on all parts</span>
<span class="sd">    of the signal, not just a few frequency bands.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    drop_freq_low : float</span>
<span class="sd">        The low end of frequencies that can be dropped,</span>
<span class="sd">        as a fraction of the sampling rate / 2.</span>
<span class="sd">    drop_freq_high : float</span>
<span class="sd">        The high end of frequencies that can be</span>
<span class="sd">        dropped, as a fraction of the sampling rate / 2.</span>
<span class="sd">    drop_count_low : int</span>
<span class="sd">        The low end of number of frequencies that could be dropped.</span>
<span class="sd">    drop_count_high : int</span>
<span class="sd">        The high end of number of frequencies that could be dropped.</span>
<span class="sd">    drop_width : float</span>
<span class="sd">        The width of the frequency band to drop, as</span>
<span class="sd">        a fraction of the sampling_rate / 2.</span>
<span class="sd">    drop_prob : float</span>
<span class="sd">        The probability that the batch of signals will  have a frequency</span>
<span class="sd">        dropped. By default, every batch has frequencies dropped.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; dropper = DropFreq()</span>
<span class="sd">    &gt;&gt;&gt; signal = read_audio(&#39;samples/audio_samples/example1.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dropped_signal = dropper(signal.unsqueeze(0))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">drop_freq_low</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">14</span><span class="p">,</span>
        <span class="n">drop_freq_high</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">drop_count_low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">drop_count_high</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">drop_width</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">drop_prob</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_freq_low</span> <span class="o">=</span> <span class="n">drop_freq_low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_freq_high</span> <span class="o">=</span> <span class="n">drop_freq_high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_count_low</span> <span class="o">=</span> <span class="n">drop_count_low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_count_high</span> <span class="o">=</span> <span class="n">drop_count_high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_width</span> <span class="o">=</span> <span class="n">drop_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_prob</span> <span class="o">=</span> <span class="n">drop_prob</span>

<div class="viewcode-block" id="DropFreq.forward"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.DropFreq.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        waveforms : tensor</span>
<span class="sd">            Shape should be `[batch, time]` or `[batch, time, channels]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor of shape `[batch, time]` or `[batch, time, channels]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Don&#39;t drop (return early) 1-`drop_prob` portion of the batches</span>
        <span class="n">dropped_waveform</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_prob</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dropped_waveform</span>

        <span class="c1"># Add channels dimension</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">dropped_waveform</span> <span class="o">=</span> <span class="n">dropped_waveform</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Pick number of frequencies to drop</span>
        <span class="n">drop_count</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
            <span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drop_count_low</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drop_count_high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
        <span class="p">)</span>

        <span class="c1"># Pick a frequency to drop</span>
        <span class="n">drop_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_freq_high</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_freq_low</span>
        <span class="n">drop_frequency</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">drop_count</span><span class="p">)</span> <span class="o">*</span> <span class="n">drop_range</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_freq_low</span>
        <span class="p">)</span>

        <span class="c1"># Filter parameters</span>
        <span class="n">filter_length</span> <span class="o">=</span> <span class="mi">101</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="n">filter_length</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="c1"># Start with delta function</span>
        <span class="n">drop_filter</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">filter_length</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">drop_filter</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Subtract each frequency</span>
        <span class="k">for</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">drop_frequency</span><span class="p">:</span>
            <span class="n">notch_kernel</span> <span class="o">=</span> <span class="n">notch_filter</span><span class="p">(</span>
                <span class="n">frequency</span><span class="p">,</span> <span class="n">filter_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_width</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="n">drop_filter</span> <span class="o">=</span> <span class="n">convolve1d</span><span class="p">(</span><span class="n">drop_filter</span><span class="p">,</span> <span class="n">notch_kernel</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>

        <span class="c1"># Apply filter</span>
        <span class="n">dropped_waveform</span> <span class="o">=</span> <span class="n">convolve1d</span><span class="p">(</span><span class="n">dropped_waveform</span><span class="p">,</span> <span class="n">drop_filter</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>

        <span class="c1"># Remove channels dimension if added</span>
        <span class="k">return</span> <span class="n">dropped_waveform</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DropChunk"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.DropChunk">[docs]</a><span class="k">class</span> <span class="nc">DropChunk</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class drops portions of the input signal.</span>

<span class="sd">    Using `DropChunk` as an augmentation strategy helps a models learn to rely</span>
<span class="sd">    on all parts of the signal, since it can&#39;t expect a given part to be</span>
<span class="sd">    present.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    drop_length_low : int</span>
<span class="sd">        The low end of lengths for which to set the</span>
<span class="sd">        signal to zero, in samples.</span>
<span class="sd">    drop_length_high : int</span>
<span class="sd">        The high end of lengths for which to set the</span>
<span class="sd">        signal to zero, in samples.</span>
<span class="sd">    drop_count_low : int</span>
<span class="sd">        The low end of number of times that the signal</span>
<span class="sd">        can be dropped to zero.</span>
<span class="sd">    drop_count_high : int</span>
<span class="sd">        The high end of number of times that the signal</span>
<span class="sd">        can be dropped to zero.</span>
<span class="sd">    drop_start : int</span>
<span class="sd">        The first index for which dropping will be allowed.</span>
<span class="sd">    drop_end : int</span>
<span class="sd">        The last index for which dropping will be allowed.</span>
<span class="sd">    drop_prob : float</span>
<span class="sd">        The probability that the batch of signals will</span>
<span class="sd">        have a portion dropped. By default, every batch</span>
<span class="sd">        has portions dropped.</span>
<span class="sd">    noise_factor : float</span>
<span class="sd">        The factor relative to average amplitude of an utterance</span>
<span class="sd">        to use for scaling the white noise inserted. 1 keeps</span>
<span class="sd">        the average amplitude the same, while 0 inserts all 0&#39;s.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; dropper = DropChunk(drop_start=100, drop_end=200, noise_factor=0.)</span>
<span class="sd">    &gt;&gt;&gt; signal = read_audio(&#39;samples/audio_samples/example1.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; signal = signal.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; length = torch.ones(1)</span>
<span class="sd">    &gt;&gt;&gt; dropped_signal = dropper(signal, length)</span>
<span class="sd">    &gt;&gt;&gt; float(dropped_signal[:, 150])</span>
<span class="sd">    0.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">drop_length_low</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">drop_length_high</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">drop_count_low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">drop_count_high</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">drop_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">drop_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">drop_prob</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">noise_factor</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_length_low</span> <span class="o">=</span> <span class="n">drop_length_low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_length_high</span> <span class="o">=</span> <span class="n">drop_length_high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_count_low</span> <span class="o">=</span> <span class="n">drop_count_low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_count_high</span> <span class="o">=</span> <span class="n">drop_count_high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_start</span> <span class="o">=</span> <span class="n">drop_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_end</span> <span class="o">=</span> <span class="n">drop_end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_prob</span> <span class="o">=</span> <span class="n">drop_prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise_factor</span> <span class="o">=</span> <span class="n">noise_factor</span>

        <span class="c1"># Validate low &lt; high</span>
        <span class="k">if</span> <span class="n">drop_length_low</span> <span class="o">&gt;</span> <span class="n">drop_length_high</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Low limit must not be more than high limit&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_count_low</span> <span class="o">&gt;</span> <span class="n">drop_count_high</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Low limit must not be more than high limit&quot;</span><span class="p">)</span>

        <span class="c1"># Make sure the length doesn&#39;t exceed end - start</span>
        <span class="k">if</span> <span class="n">drop_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">drop_end</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_start</span> <span class="o">&gt;</span> <span class="n">drop_end</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Low limit must not be more than high limit&quot;</span><span class="p">)</span>

            <span class="n">drop_range</span> <span class="o">=</span> <span class="n">drop_end</span> <span class="o">-</span> <span class="n">drop_start</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drop_length_low</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">drop_length_low</span><span class="p">,</span> <span class="n">drop_range</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drop_length_high</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">drop_length_high</span><span class="p">,</span> <span class="n">drop_range</span><span class="p">)</span>

<div class="viewcode-block" id="DropChunk.forward"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.DropChunk.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">,</span> <span class="n">lengths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        waveforms : tensor</span>
<span class="sd">            Shape should be `[batch, time]` or `[batch, time, channels]`.</span>
<span class="sd">        lengths : tensor</span>
<span class="sd">            Shape should be a single dimension, `[batch]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor of shape `[batch, time]` or</span>
<span class="sd">            `[batch, time, channels]`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Reading input list</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">(</span><span class="n">lengths</span> <span class="o">*</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dropped_waveform</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="c1"># Don&#39;t drop (return early) 1-`drop_prob` portion of the batches</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_prob</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dropped_waveform</span>

        <span class="c1"># Store original amplitude for computing white noise amplitude</span>
        <span class="n">clean_amplitude</span> <span class="o">=</span> <span class="n">compute_amplitude</span><span class="p">(</span><span class="n">waveforms</span><span class="p">,</span> <span class="n">lengths</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Pick a number of times to drop</span>
        <span class="n">drop_times</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
            <span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drop_count_low</span><span class="p">,</span>
            <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drop_count_high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,),</span>
        <span class="p">)</span>

        <span class="c1"># Iterate batch to set mask</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">drop_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Pick lengths</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
                <span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drop_length_low</span><span class="p">,</span>
                <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drop_length_high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">drop_times</span><span class="p">[</span><span class="n">i</span><span class="p">],),</span>
            <span class="p">)</span>

            <span class="c1"># Compute range of starting locations</span>
            <span class="n">start_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_start</span>
            <span class="k">if</span> <span class="n">start_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start_min</span> <span class="o">+=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">start_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_end</span>
            <span class="k">if</span> <span class="n">start_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_max</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">start_max</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start_max</span> <span class="o">+=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">start_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_max</span> <span class="o">-</span> <span class="n">length</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

            <span class="c1"># Pick starting locations</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span>
                <span class="n">low</span><span class="o">=</span><span class="n">start_min</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">start_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">drop_times</span><span class="p">[</span><span class="n">i</span><span class="p">],),</span>
            <span class="p">)</span>

            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span>

            <span class="c1"># Update waveform</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_factor</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">drop_times</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="n">dropped_waveform</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span> <span class="n">end</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Uniform distribution of -2 to +2 * avg amplitude should</span>
                <span class="c1"># preserve the average for normalization</span>
                <span class="n">noise_max</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">clean_amplitude</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_factor</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">drop_times</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="c1"># zero-center the noise distribution</span>
                    <span class="n">noise_vec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">length</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">waveforms</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                    <span class="n">noise_vec</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">noise_max</span> <span class="o">*</span> <span class="n">noise_vec</span> <span class="o">-</span> <span class="n">noise_max</span>
                    <span class="n">dropped_waveform</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span> <span class="n">end</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">noise_vec</span>

        <span class="k">return</span> <span class="n">dropped_waveform</span></div></div>


<div class="viewcode-block" id="DoClip"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.DoClip">[docs]</a><span class="k">class</span> <span class="nc">DoClip</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function mimics audio clipping by clamping the input tensor.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    clip_low : float</span>
<span class="sd">        The low end of amplitudes for which to clip the signal.</span>
<span class="sd">    clip_high : float</span>
<span class="sd">        The high end of amplitudes for which to clip the signal.</span>
<span class="sd">    clip_prob : float</span>
<span class="sd">        The probability that the batch of signals will have a portion clipped.</span>
<span class="sd">        By default, every batch has portions clipped.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; clipper = DoClip(clip_low=0.01, clip_high=0.01)</span>
<span class="sd">    &gt;&gt;&gt; signal = read_audio(&#39;samples/audio_samples/example1.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; clipped_signal = clipper(signal.unsqueeze(0))</span>
<span class="sd">    &gt;&gt;&gt; &quot;%.2f&quot; % clipped_signal.max()</span>
<span class="sd">    &#39;0.01&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">clip_low</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">clip_high</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">clip_prob</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip_low</span> <span class="o">=</span> <span class="n">clip_low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip_high</span> <span class="o">=</span> <span class="n">clip_high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip_prob</span> <span class="o">=</span> <span class="n">clip_prob</span>

<div class="viewcode-block" id="DoClip.forward"><a class="viewcode-back" href="../../../speechbrain.processing.speech_augmentation.html#speechbrain.processing.speech_augmentation.DoClip.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waveforms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        waveforms : tensor</span>
<span class="sd">            Shape should be `[batch, time]` or `[batch, time, channels]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tensor of shape `[batch, time]` or `[batch, time, channels]`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Don&#39;t clip (return early) 1-`clip_prob` portion of the batches</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">clip_prob</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="c1"># Randomly select clip value</span>
        <span class="n">clipping_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clip_high</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">clip_low</span>
        <span class="n">clip_value</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">,)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">clipping_range</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">clip_low</span>

        <span class="c1"># Apply clipping</span>
        <span class="n">clipped_waveform</span> <span class="o">=</span> <span class="n">waveforms</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="o">-</span><span class="n">clip_value</span><span class="p">,</span> <span class="n">clip_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">clipped_waveform</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, SpeechBrain

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>