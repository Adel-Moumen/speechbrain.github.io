

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>speechbrain.dataio.encoder &mdash; SpeechBrain 0.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> SpeechBrain
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Quick installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#install-via-pypi">Install via PyPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#install-locally">Install locally</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#test-installation">Test Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../experiment.html">Running an experiment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../experiment.html#yaml-basics">YAML basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../experiment.html#running-arguments">Running arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../experiment.html#tensor-format">Tensor format</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../multigpu.html">Basics of multi-GPU</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../multigpu.html#multi-gpu-training-using-data-parallel">Multi-GPU training using Data Parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../multigpu.html#multi-gpu-training-using-distributed-data-parallel-ddp">Multi-GPU training using Distributed Data Parallel (DDP)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../multigpu.html#with-multiple-machines-suppose-you-have-2-servers-with-2-gpus">With multiple machines (suppose you have 2 servers with 2 GPUs):</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#zen-of-speechbrain">Zen of Speechbrain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#how-to-get-your-code-in-speechbrain">How to get your code in SpeechBrain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#python">Python</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#version">Version</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#formatting">Formatting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#adding-dependencies">Adding dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#testing">Testing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#documentation">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#development-tools">Development tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#flake8">flake8</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#pre-commit">pre-commit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#the-git-pre-commit-hooks">the git pre-commit hooks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#the-git-pre-push-hooks">the git pre-push hooks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#pytest-doctests">pytest doctests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#continuous-integration">Continuous integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#what-is-ci">What is CI?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#ci-cd-pipelines">CI / CD Pipelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#our-test-suite">Our test suite</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#pull-request-review-guide">Pull Request review guide</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">API Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../speechbrain.html">Core library (speechbrain)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.core.html">speechbrain.core module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.core.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.core.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.yaml.html">speechbrain.yaml module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.alignment.html">speechbrain.alignment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.alignment.aligner.html">speechbrain.alignment.aligner module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.alignment.aligner.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.alignment.aligner.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.dataio.html">speechbrain.dataio</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.batch.html">speechbrain.dataio.batch module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.batch.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.batch.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.dataio.html">speechbrain.dataio.dataio module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataio.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataio.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.dataloader.html">speechbrain.dataio.dataloader module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataloader.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataloader.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.dataset.html">speechbrain.dataio.dataset module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataset.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataset.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.encoder.html">speechbrain.dataio.encoder module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.encoder.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.encoder.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.legacy.html">speechbrain.dataio.legacy module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.legacy.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.legacy.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.sampler.html">speechbrain.dataio.sampler module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.sampler.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.sampler.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.wer.html">speechbrain.dataio.wer module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.wer.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.wer.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.decoders.html">speechbrain.decoders</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.decoders.ctc.html">speechbrain.decoders.ctc module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.ctc.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.ctc.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.decoders.seq2seq.html">speechbrain.decoders.seq2seq module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.seq2seq.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.seq2seq.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.decoders.transducer.html">speechbrain.decoders.transducer module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.transducer.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.transducer.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.lm.html">speechbrain.lm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lm.arpa.html">speechbrain.lm.arpa module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.arpa.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.arpa.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lm.counting.html">speechbrain.lm.counting module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.counting.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.counting.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lm.ngram.html">speechbrain.lm.ngram module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.ngram.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.ngram.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.lobes.html">speechbrain.lobes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lobes.augment.html">speechbrain.lobes.augment module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.augment.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.augment.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lobes.features.html">speechbrain.lobes.features module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.features.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.features.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lobes.models.html">speechbrain.lobes.models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.CRDNN.html">speechbrain.lobes.models.CRDNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.ContextNet.html">speechbrain.lobes.models.ContextNet module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.ECAPA_TDNN.html">speechbrain.lobes.models.ECAPA_TDNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.ESPnetVGG.html">speechbrain.lobes.models.ESPnetVGG module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.MetricGAN_D.html">speechbrain.lobes.models.MetricGAN_D module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.RNNLM.html">speechbrain.lobes.models.RNNLM module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.VanillaNN.html">speechbrain.lobes.models.VanillaNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.Xvector.html">speechbrain.lobes.models.Xvector module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.conv_tasnet.html">speechbrain.lobes.models.conv_tasnet module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.convolution.html">speechbrain.lobes.models.convolution module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.dual_path.html">speechbrain.lobes.models.dual_path module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.transformer.html">speechbrain.lobes.models.transformer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.nnet.html">speechbrain.nnet</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.CNN.html">speechbrain.nnet.CNN module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.CNN.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.CNN.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.RNN.html">speechbrain.nnet.RNN module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.RNN.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.RNN.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.activations.html">speechbrain.nnet.activations module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.activations.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.activations.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.attention.html">speechbrain.nnet.attention module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.attention.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.attention.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.containers.html">speechbrain.nnet.containers module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.containers.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.containers.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.dropout.html">speechbrain.nnet.dropout module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.dropout.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.dropout.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.embedding.html">speechbrain.nnet.embedding module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.embedding.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.embedding.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.linear.html">speechbrain.nnet.linear module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.linear.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.linear.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.losses.html">speechbrain.nnet.losses module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.losses.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.losses.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.normalization.html">speechbrain.nnet.normalization module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.normalization.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.normalization.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.pooling.html">speechbrain.nnet.pooling module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.pooling.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.pooling.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.schedulers.html">speechbrain.nnet.schedulers module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.schedulers.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.schedulers.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.html">speechbrain.nnet.complex_networks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_CNN.html">speechbrain.nnet.complex_networks.c_CNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_RNN.html">speechbrain.nnet.complex_networks.c_RNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_linear.html">speechbrain.nnet.complex_networks.c_linear module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_normalization.html">speechbrain.nnet.complex_networks.c_normalization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_ops.html">speechbrain.nnet.complex_networks.c_ops module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.loss.html">speechbrain.nnet.loss</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.loss.stoi_loss.html">speechbrain.nnet.loss.stoi_loss module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.loss.transducer_loss.html">speechbrain.nnet.loss.transducer_loss module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.html">speechbrain.nnet.quaternion_networks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_CNN.html">speechbrain.nnet.quaternion_networks.q_CNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_RNN.html">speechbrain.nnet.quaternion_networks.q_RNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_linear.html">speechbrain.nnet.quaternion_networks.q_linear module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_normalization.html">speechbrain.nnet.quaternion_networks.q_normalization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_ops.html">speechbrain.nnet.quaternion_networks.q_ops module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.transducer.html">speechbrain.nnet.transducer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.transducer.transducer_joint.html">speechbrain.nnet.transducer.transducer_joint module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.processing.html">speechbrain.processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.NMF.html">speechbrain.processing.NMF module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.NMF.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.NMF.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.PLDA_LDA.html">speechbrain.processing.PLDA_LDA module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.PLDA_LDA.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.PLDA_LDA.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.decomposition.html">speechbrain.processing.decomposition module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.decomposition.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.decomposition.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.diarization.html">speechbrain.processing.diarization module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.diarization.html#reference">Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.diarization.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.diarization.html#id1">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.features.html">speechbrain.processing.features module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.features.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.features.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.multi_mic.html">speechbrain.processing.multi_mic module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.multi_mic.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.multi_mic.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.signal_processing.html">speechbrain.processing.signal_processing module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.signal_processing.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.signal_processing.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.speech_augmentation.html">speechbrain.processing.speech_augmentation module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.speech_augmentation.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.speech_augmentation.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.tokenizers.html">speechbrain.tokenizers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.tokenizers.SentencePiece.html">speechbrain.tokenizers.SentencePiece module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.tokenizers.SentencePiece.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.tokenizers.SentencePiece.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.utils.html">speechbrain.utils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.Accuracy.html">speechbrain.utils.Accuracy module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.Accuracy.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.Accuracy.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.DER.html">speechbrain.utils.DER module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.DER.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.DER.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.checkpoints.html">speechbrain.utils.checkpoints module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.checkpoints.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.checkpoints.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.convert_model.html">speechbrain.utils.convert_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.data_pipeline.html">speechbrain.utils.data_pipeline module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_pipeline.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_pipeline.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.data_utils.html">speechbrain.utils.data_utils module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_utils.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_utils.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.depgraph.html">speechbrain.utils.depgraph module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.depgraph.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.depgraph.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.distributed.html">speechbrain.utils.distributed module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.distributed.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.distributed.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.edit_distance.html">speechbrain.utils.edit_distance module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.edit_distance.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.edit_distance.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.epoch_loop.html">speechbrain.utils.epoch_loop module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.epoch_loop.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.epoch_loop.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.logger.html">speechbrain.utils.logger module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.logger.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.logger.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.metric_stats.html">speechbrain.utils.metric_stats module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.metric_stats.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.metric_stats.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.parameter_transfer.html">speechbrain.utils.parameter_transfer module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.parameter_transfer.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.parameter_transfer.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.superpowers.html">speechbrain.utils.superpowers module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.superpowers.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.superpowers.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.train_logger.html">speechbrain.utils.train_logger module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.train_logger.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.train_logger.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools.html">Runnable Tools (tools)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tools.compute_wer.html">tools.compute_wer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tools.compute_wer.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SpeechBrain</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>speechbrain.dataio.encoder</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for speechbrain.dataio.encoder</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Encoding categorical data as integers</span>

<span class="sd">Authors</span>
<span class="sd">  * Samuele Cornell 2020</span>
<span class="sd">  * Aku Rouhe 2020</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">speechbrain</span> <span class="k">as</span> <span class="nn">sb</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="c1"># NOTE: Changing these does NOT change the defaults in the classes.</span>
<span class="c1"># Consider these read-only.</span>
<span class="n">DEFAULT_UNK</span> <span class="o">=</span> <span class="s2">&quot;&lt;unk&gt;&quot;</span>
<span class="n">DEFAULT_BOS</span> <span class="o">=</span> <span class="s2">&quot;&lt;bos&gt;&quot;</span>
<span class="n">DEFAULT_EOS</span> <span class="o">=</span> <span class="s2">&quot;&lt;eos&gt;&quot;</span>
<span class="n">DEFAULT_BLANK</span> <span class="o">=</span> <span class="s2">&quot;&lt;blank&gt;&quot;</span>


<div class="viewcode-block" id="CategoricalEncoder"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder">[docs]</a><span class="k">class</span> <span class="nc">CategoricalEncoder</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Encode labels of a discrete set.</span>

<span class="sd">    Used for encoding, e.g., speaker identities in speaker recognition.</span>
<span class="sd">    Given a collection of hashables (e.g a strings) it encodes</span>
<span class="sd">    every unique item to an integer value: [&quot;spk0&quot;, &quot;spk1&quot;] --&gt; [0, 1]</span>
<span class="sd">    Internally the correspondence between each label to its index is handled by</span>
<span class="sd">    two dictionaries: lab2ind and ind2lab.</span>

<span class="sd">    The label integer encoding can be generated automatically from a SpeechBrain</span>
<span class="sd">    DynamicItemDataset by specifying the desired entry (e.g., spkid) in the annotation</span>
<span class="sd">    and calling update_from_didataset method:</span>

<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.encoder import CategoricalEncoder</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataset import DynamicItemDataset</span>
<span class="sd">    &gt;&gt;&gt; dataset = {&quot;ex_{}&quot;.format(x) : {&quot;spkid&quot; : &quot;spk{}&quot;.format(x)} for x in range(20)}</span>
<span class="sd">    &gt;&gt;&gt; dataset = DynamicItemDataset(dataset)</span>
<span class="sd">    &gt;&gt;&gt; encoder = CategoricalEncoder()</span>
<span class="sd">    &gt;&gt;&gt; encoder.update_from_didataset(dataset, &quot;spkid&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert len(encoder) == len(dataset) # different speaker for each utterance</span>

<span class="sd">    However can also be updated from an iterable:</span>

<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.encoder import CategoricalEncoder</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataset import DynamicItemDataset</span>
<span class="sd">    &gt;&gt;&gt; dataset = [&quot;spk{}&quot;.format(x) for x in range(20)]</span>
<span class="sd">    &gt;&gt;&gt; encoder = CategoricalEncoder()</span>
<span class="sd">    &gt;&gt;&gt; encoder.update_from_iterable(dataset)</span>
<span class="sd">    &gt;&gt;&gt; assert len(encoder) == len(dataset)</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    In both methods it can be specified it the single element in the iterable</span>
<span class="sd">    or in the dataset should be treated as a sequence or not (default False).</span>
<span class="sd">    If it is a sequence each element in the sequence will be encoded.</span>


<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.encoder import CategoricalEncoder</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataset import DynamicItemDataset</span>
<span class="sd">    &gt;&gt;&gt; dataset = [[x+1, x+2] for x in range(20)]</span>
<span class="sd">    &gt;&gt;&gt; encoder = CategoricalEncoder()</span>
<span class="sd">    &gt;&gt;&gt; encoder.update_from_iterable(dataset, sequence_input=True)</span>
<span class="sd">    &gt;&gt;&gt; assert len(encoder) == 21 # there are only 21 unique elements 1-21</span>

<span class="sd">    This class offers 4 different methods to explicitly add a label in the internal</span>
<span class="sd">    dicts: add_label, ensure_label, insert_label, enforce_label.</span>
<span class="sd">    add_label and insert_label will raise an error if it is already present in the</span>
<span class="sd">    internal dicts. insert_label, enforce_label allow also to specify the integer value</span>
<span class="sd">    to which the desired label is encoded.</span>

<span class="sd">    Encoding can be performed using 4 different methods:</span>
<span class="sd">    encode_label, encode_sequence, encode_label_torch and encode_sequence_torch.</span>
<span class="sd">    encode_label operate on single labels and simply returns the corresponding</span>
<span class="sd">    integer encoding:</span>

<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.encoder import CategoricalEncoder</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataset import DynamicItemDataset</span>
<span class="sd">    &gt;&gt;&gt; dataset = [&quot;spk{}&quot;.format(x) for x in range(20)]</span>
<span class="sd">    &gt;&gt;&gt; encoder.update_from_iterable(dataset)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    22</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    encode_sequence on sequences of labels:</span>
<span class="sd">    &gt;&gt;&gt; encoder.encode_sequence([&quot;spk1&quot;, &quot;spk19&quot;])</span>
<span class="sd">    [22, 40]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    encode_label_torch and encode_sequence_torch return torch tensors</span>
<span class="sd">    &gt;&gt;&gt; encoder.encode_sequence_torch([&quot;spk1&quot;, &quot;spk19&quot;])</span>
<span class="sd">    tensor([22, 40])</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    Decoding can be performed using decode_torch and decode_ndim methods.</span>
<span class="sd">    &gt;&gt;&gt; encoded = encoder.encode_sequence_torch([&quot;spk1&quot;, &quot;spk19&quot;])</span>
<span class="sd">    &gt;&gt;&gt; encoder.decode_torch(encoded)</span>
<span class="sd">    [&#39;spk1&#39;, &#39;spk19&#39;]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    decode_ndim is used for multidimensional list or pytorch tensors</span>
<span class="sd">    &gt;&gt;&gt; encoded = encoded.unsqueeze(0).repeat(3, 1)</span>
<span class="sd">    &gt;&gt;&gt; encoder.decode_torch(encoded)</span>
<span class="sd">    [[&#39;spk1&#39;, &#39;spk19&#39;], [&#39;spk1&#39;, &#39;spk19&#39;], [&#39;spk1&#39;, &#39;spk19&#39;]]</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    In some applications, it can happen that during testing a label which has not</span>
<span class="sd">    been encountered during training is encountered. To handle this out-of-vocabulary</span>
<span class="sd">    problem add_unk can be used. Every out-of-vocab label is mapped to this special</span>
<span class="sd">    &lt;unk&gt; label and its corresponding integer encoding.</span>

<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     encoder.encode_label(&quot;spk42&quot;)</span>
<span class="sd">    ... except KeyError:</span>
<span class="sd">    ...        print(&quot;spk42 is not in the encoder this raises an error!&quot;)</span>
<span class="sd">    spk42 is not in the encoder this raises an error!</span>
<span class="sd">    &gt;&gt;&gt; encoder.add_unk()</span>
<span class="sd">    41</span>
<span class="sd">    &gt;&gt;&gt; encoder.encode_label(&quot;spk42&quot;)</span>
<span class="sd">    41</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    returns the &lt;unk&gt; encoding</span>

<span class="sd">    This class offers also methods to save and load the internal mappings between</span>
<span class="sd">    labels and tokens using: save and load methods as well as load_or_create.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">VALUE_SEPARATOR</span> <span class="o">=</span> <span class="s2">&quot; =&gt; &quot;</span>
    <span class="n">EXTRAS_SEPARATOR</span> <span class="o">=</span> <span class="s2">&quot;================</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starting_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">special_labels</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">starting_index</span> <span class="o">=</span> <span class="n">starting_index</span>
        <span class="c1"># NOTE: unk_label is not necessarily set at all!</span>
        <span class="c1"># This is because None is a suitable value for unk.</span>
        <span class="c1"># So the test is: hasattr(self, &quot;unk_label&quot;)</span>
        <span class="c1"># rather than self.unk_label is not None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handle_special_labels</span><span class="p">(</span><span class="n">special_labels</span><span class="p">)</span>

<div class="viewcode-block" id="CategoricalEncoder.handle_special_labels"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.handle_special_labels">[docs]</a>    <span class="k">def</span> <span class="nf">handle_special_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">special_labels</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;unk_label&quot;</span> <span class="ow">in</span> <span class="n">special_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_unk</span><span class="p">(</span><span class="n">special_labels</span><span class="p">[</span><span class="s2">&quot;unk_label&quot;</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">)</span>

<div class="viewcode-block" id="CategoricalEncoder.from_saved"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.from_saved">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_saved</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recreate a previously saved encoder directly&quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">cls</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="CategoricalEncoder.update_from_iterable"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.update_from_iterable">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">sequence_input</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update from iterator</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        iterable : iterable</span>
<span class="sd">            Input sequence on which to operate.</span>
<span class="sd">        sequence_input : bool</span>
<span class="sd">            Whether iterable yields sequences of labels or individual labels</span>
<span class="sd">            directly. (default False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sequence_input</span><span class="p">:</span>
            <span class="n">label_iterator</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label_iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">label_iterator</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ensure_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="CategoricalEncoder.update_from_didataset"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.update_from_didataset">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_didataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">didataset</span><span class="p">,</span> <span class="n">output_key</span><span class="p">,</span> <span class="n">sequence_input</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update from DynamicItemDataset.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        didataset : DynamicItemDataset</span>
<span class="sd">            Dataset on which to operate.</span>
<span class="sd">        output_key : str</span>
<span class="sd">            Key in the dataset (in data or a dynamic item) to encode.</span>
<span class="sd">        sequence_input : bool</span>
<span class="sd">            Whether the data yielded with the specified key consists of</span>
<span class="sd">            sequences of labels or individual labels directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">didataset</span><span class="o">.</span><span class="n">output_keys_as</span><span class="p">([</span><span class="n">output_key</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_from_iterable</span><span class="p">(</span>
                <span class="p">(</span><span class="n">data_point</span><span class="p">[</span><span class="n">output_key</span><span class="p">]</span> <span class="k">for</span> <span class="n">data_point</span> <span class="ow">in</span> <span class="n">didataset</span><span class="p">),</span>
                <span class="n">sequence_input</span><span class="o">=</span><span class="n">sequence_input</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="CategoricalEncoder.limited_labelset_from_iterable"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.limited_labelset_from_iterable">[docs]</a>    <span class="k">def</span> <span class="nf">limited_labelset_from_iterable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">sequence_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_most_common</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce label mapping from iterable based on label counts</span>

<span class="sd">        Used to limit label set size.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        iterable : iterable</span>
<span class="sd">            Input sequence on which to operate.</span>
<span class="sd">        sequence_input : bool</span>
<span class="sd">            Whether iterable yields sequences of labels or individual labels</span>
<span class="sd">            directly. False by default.</span>
<span class="sd">        n_most_common : int, None</span>
<span class="sd">            Take at most this many labels as the label set, keeping the most</span>
<span class="sd">            common ones. If None (as by default), take all.</span>
<span class="sd">        min_count : int</span>
<span class="sd">            Don&#39;t take labels if they appear less than this many times.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        collections.Counter</span>
<span class="sd">            The counts of the different labels (unfiltered).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">:</span>
            <span class="n">clsname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;Limited_labelset_from_iterable called, &quot;</span>
                <span class="n">f</span><span class="s2">&quot;but </span><span class="si">{clsname}</span><span class="s2"> is not empty. &quot;</span>
                <span class="s2">&quot;The new labels will be added, i.e. won&#39;t overwrite. &quot;</span>
                <span class="s2">&quot;This is normal if there is e.g. an unk label already.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">sequence_input</span><span class="p">:</span>
            <span class="n">label_iterator</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label_iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">label_iterator</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="n">n_most_common</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">min_count</span><span class="p">:</span>
                <span class="c1"># .most_common() produces counts in descending order,</span>
                <span class="c1"># so no more labels can be found</span>
                <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">counts</span></div>

<div class="viewcode-block" id="CategoricalEncoder.load_or_create"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.load_or_create">[docs]</a>    <span class="k">def</span> <span class="nf">load_or_create</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">,</span>
        <span class="n">from_iterables</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">from_didatasets</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">sequence_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">special_labels</span><span class="o">=</span><span class="p">{},</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenient syntax for creating the encoder conditionally</span>

<span class="sd">        This pattern would be repeated in so many experiments that</span>
<span class="sd">        we decided to add a convenient shortcut for it here. The</span>
<span class="sd">        current version is multi-gpu (DDP) safe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">if_main_process</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_if_possible</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">iterable</span> <span class="ow">in</span> <span class="n">from_iterables</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">update_from_iterable</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">sequence_input</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">didataset</span> <span class="ow">in</span> <span class="n">from_didatasets</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">output_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;Provide an output_key for &quot;</span>
                                <span class="s2">&quot;DynamicItemDataset&quot;</span>
                            <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">update_from_didataset</span><span class="p">(</span>
                            <span class="n">didataset</span><span class="p">,</span> <span class="n">output_key</span><span class="p">,</span> <span class="n">sequence_input</span>
                        <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">handle_special_labels</span><span class="p">(</span><span class="n">special_labels</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">sb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">ddp_barrier</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="CategoricalEncoder.add_label"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.add_label">[docs]</a>    <span class="k">def</span> <span class="nf">add_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add new label to the encoder, at the next free position.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        label : hashable</span>
<span class="sd">            Most often labels are str, but anything that can act as dict key is</span>
<span class="sd">            supported. Note that default save/load only supports Python</span>
<span class="sd">            literals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The index that was used to encode this label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">:</span>
            <span class="n">clsname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Label already present in </span><span class="si">{clsname}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_index</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
        <span class="k">return</span> <span class="n">index</span></div>

<div class="viewcode-block" id="CategoricalEncoder.ensure_label"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.ensure_label">[docs]</a>    <span class="k">def</span> <span class="nf">ensure_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a label if it is not already present.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        label : hashable</span>
<span class="sd">            Most often labels are str, but anything that can act as dict key is</span>
<span class="sd">            supported. Note that default save/load only supports Python</span>
<span class="sd">            literals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The index that was used to encode this label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span></div>

<div class="viewcode-block" id="CategoricalEncoder.insert_label"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.insert_label">[docs]</a>    <span class="k">def</span> <span class="nf">insert_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new label, forcing its index to a specific value.</span>

<span class="sd">        If a label already has the specified index, it is moved to the end</span>
<span class="sd">        of the mapping.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        label : hashable</span>
<span class="sd">            Most often labels are str, but anything that can act as dict key is</span>
<span class="sd">            supported. Note that default save/load only supports Python</span>
<span class="sd">            literals.</span>
<span class="sd">        index : int</span>
<span class="sd">            The specific index to use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">:</span>
            <span class="n">clsname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Label already present in </span><span class="si">{clsname}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enforce_label</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span></div>

<div class="viewcode-block" id="CategoricalEncoder.enforce_label"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.enforce_label">[docs]</a>    <span class="k">def</span> <span class="nf">enforce_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make sure label is present and encoded to a particular index.</span>

<span class="sd">        If the label is present but encoded to some other index, it is</span>
<span class="sd">        moved to the given index.</span>

<span class="sd">        If there is already another label at the</span>
<span class="sd">        given index, that label is moved to the next free position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="n">label</span><span class="p">]:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Delete old index mapping. Everything else gets overwritten.</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="n">label</span><span class="p">]]</span>
        <span class="c1"># Move other label out of the way:</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span><span class="p">:</span>
            <span class="n">saved_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">moving_other</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">moving_other</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Ready to push the new index.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
        <span class="c1"># And finally put the moved index in new spot.</span>
        <span class="k">if</span> <span class="n">moving_other</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;Moving label {repr(saved_label)} from index &quot;</span>
                <span class="n">f</span><span class="s2">&quot;</span><span class="si">{index}</span><span class="s2">, because {repr(label)} was put at its place.&quot;</span>
            <span class="p">)</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_index</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="n">saved_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span><span class="p">[</span><span class="n">new_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">saved_label</span></div>

<div class="viewcode-block" id="CategoricalEncoder.add_unk"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.add_unk">[docs]</a>    <span class="k">def</span> <span class="nf">add_unk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unk_label</span><span class="o">=</span><span class="n">DEFAULT_UNK</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add label for unknown tokens (out-of-vocab).</span>

<span class="sd">        When asked to encode unknown labels, they can be mapped to this.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        label : hashable, optional</span>
<span class="sd">            Most often labels are str, but anything that can act as dict key is</span>
<span class="sd">            supported. Note that default save/load only supports Python</span>
<span class="sd">            literals. Default: &lt;unk&gt;. This can be None, as well!</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The index that was used to encode this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unk_label</span> <span class="o">=</span> <span class="n">unk_label</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span><span class="p">(</span><span class="n">unk_label</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_next_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The index to use for the next new label&quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">starting_index</span>
        <span class="k">while</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">index</span>

<div class="viewcode-block" id="CategoricalEncoder.is_continuous"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.is_continuous">[docs]</a>    <span class="k">def</span> <span class="nf">is_continuous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that the set of indices doesn&#39;t have gaps</span>

<span class="sd">        For example:</span>
<span class="sd">        If starting index = 1</span>
<span class="sd">        Continuous: [1,2,3,4]</span>
<span class="sd">        Continuous: [0,1,2]</span>
<span class="sd">        Non-continuous: [2,3,4]</span>
<span class="sd">        Non-continuous: [1,2,4]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if continuous.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Because of Python indexing this also handles the special cases</span>
        <span class="c1"># of 0 or 1 labels.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">starting_index</span> <span class="ow">in</span> <span class="n">indices</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CategoricalEncoder.encode_label"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.encode_label">[docs]</a>    <span class="k">def</span> <span class="nf">encode_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">allow_unk</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encode label to int</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        label : hashable</span>
<span class="sd">            Label to encode, must exist in the mapping.</span>
<span class="sd">        allow_unk : bool</span>
<span class="sd">            If given, that label is not in the label set</span>
<span class="sd">            AND unk_label has been added with add_unk(),</span>
<span class="sd">            allows encoding to unk_label&#39;s index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Corresponding encoded int value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;unk_label&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">allow_unk</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">unk_label</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;unk_label&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_unk</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="n">f</span><span class="s2">&quot;Unknown label </span><span class="si">{label}</span><span class="s2">, and explicitly &quot;</span>
                    <span class="s2">&quot;disallowed the use of the existing unk-label&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;unk_label&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">allow_unk</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="n">f</span><span class="s2">&quot;Cannot encode unknown label </span><span class="si">{label}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;You have not called add_unk() to add a special &quot;</span>
                    <span class="s2">&quot;unk-label for unknown labels.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="n">f</span><span class="s2">&quot;Couldn&#39;t and wouldn&#39;t encode unknown label &quot;</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{label}</span><span class="s2">.&quot;</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="CategoricalEncoder.encode_label_torch"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.encode_label_torch">[docs]</a>    <span class="k">def</span> <span class="nf">encode_label_torch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">allow_unk</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encode label to torch.LongTensor.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        label : hashable</span>
<span class="sd">            Label to encode, must exist in the mapping.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.LongTensor</span>
<span class="sd">            Corresponding encoded int value.</span>
<span class="sd">            Tensor shape [1].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">encode_label</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">allow_unk</span><span class="p">)])</span></div>

<div class="viewcode-block" id="CategoricalEncoder.encode_sequence"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.encode_sequence">[docs]</a>    <span class="k">def</span> <span class="nf">encode_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">allow_unk</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encode a sequence of labels to list</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        x : iterable</span>
<span class="sd">            Labels to encode, must exist in the mapping.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Corresponding integer labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">encode_label</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">allow_unk</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">]</span></div>

<div class="viewcode-block" id="CategoricalEncoder.encode_sequence_torch"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.encode_sequence_torch">[docs]</a>    <span class="k">def</span> <span class="nf">encode_sequence_torch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">allow_unk</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encode a sequence of labels to torch.LongTensor</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        x : iterable</span>
<span class="sd">            Labels to encode, must exist in the mapping.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.LongTensor</span>
<span class="sd">            Corresponding integer labels.</span>
<span class="sd">            Tensor shape [len(sequence)].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">encode_label</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">allow_unk</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CategoricalEncoder.decode_torch"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.decode_torch">[docs]</a>    <span class="k">def</span> <span class="nf">decode_torch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decodes an arbitrarily nested torch.Tensor to a list of labels.</span>

<span class="sd">        Provided separately because Torch provides clearer introspection,</span>
<span class="sd">        and so doesn&#39;t require try-except.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        x : torch.Tensor</span>
<span class="sd">            Torch tensor of some integer dtype (Long, int) and any shape to</span>
<span class="sd">            decode.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of original labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">decoded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Recursively operates on the different dimensions.</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Last dimension!</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">decoded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">element</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subtensor</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">decoded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decode_torch</span><span class="p">(</span><span class="n">subtensor</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">decoded</span></div>

<div class="viewcode-block" id="CategoricalEncoder.decode_ndim"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.decode_ndim">[docs]</a>    <span class="k">def</span> <span class="nf">decode_ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decodes an arbitrarily nested iterable to a list of labels.</span>

<span class="sd">        This works for essentially any pythonic iterable (including torch), and</span>
<span class="sd">        also single elements.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        x : Any</span>
<span class="sd">            Python list or other iterable or torch.Tensor or a single integer element</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list, Any</span>
<span class="sd">            ndim list of original labels, or if input was single element,</span>
<span class="sd">            output will be, too.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Recursively operates on the different dimensions.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">decoded</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">subtensor</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">decoded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decode_ndim</span><span class="p">(</span><span class="n">subtensor</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">decoded</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># Not an iterable, bottom level!</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span></div>

<div class="viewcode-block" id="CategoricalEncoder.save"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the categorical encoding for later use and recovery</span>

<span class="sd">        Saving uses a Python literal format, which supports things like</span>
<span class="sd">        tuple labels, but is considered safe to load (unlike e.g. pickle).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        path : str, Path</span>
<span class="sd">            Where to save. Will overwrite.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extras</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_literal</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">,</span> <span class="n">extras</span><span class="p">)</span></div>

<div class="viewcode-block" id="CategoricalEncoder.load"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads from the given path.</span>

<span class="sd">        CategoricalEncoder uses a Python literal format, which supports things</span>
<span class="sd">        like tuple labels, but is considered safe to load (unlike e.g. pickle).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        path : str, Path</span>
<span class="sd">            Where to load from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">:</span>
            <span class="n">clsname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;Load called, but </span><span class="si">{clsname}</span><span class="s2"> is not empty. &quot;</span>
                <span class="s2">&quot;Loaded data will overwrite everything. &quot;</span>
                <span class="s2">&quot;This is normal if there is e.g. an unk label defined at init.&quot;</span>
            <span class="p">)</span>
        <span class="n">lab2ind</span><span class="p">,</span> <span class="n">ind2lab</span><span class="p">,</span> <span class="n">extras</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_literal</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span> <span class="o">=</span> <span class="n">lab2ind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ind2lab</span> <span class="o">=</span> <span class="n">ind2lab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_extras</span><span class="p">(</span><span class="n">extras</span><span class="p">)</span>
        <span class="c1"># If we&#39;re here, load was a success!</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Loaded categorical encoding from </span><span class="si">{path}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CategoricalEncoder.load_if_possible"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CategoricalEncoder.load_if_possible">[docs]</a>    <span class="k">def</span> <span class="nf">load_if_possible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads if possible, returns a bool indicating if loaded or not.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        path : str, Path</span>
<span class="sd">            Where to load from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool :</span>
<span class="sd">            If load was successful.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; encoding_file = getfixture(&#39;tmpdir&#39;) / &quot;encoding.txt&quot;</span>
<span class="sd">        &gt;&gt;&gt; encoder = CategoricalEncoder()</span>
<span class="sd">        &gt;&gt;&gt; # The idea is in an experiment script to have something like this:</span>
<span class="sd">        &gt;&gt;&gt; if not encoder.load_if_possible(encoding_file):</span>
<span class="sd">        ...     encoder.update_from_iterable(&quot;abcd&quot;)</span>
<span class="sd">        ...     encoder.save(encoding_file)</span>
<span class="sd">        &gt;&gt;&gt; # So the first time you run the experiment, the encoding is created.</span>
<span class="sd">        &gt;&gt;&gt; # However, later, the encoding exists:</span>
<span class="sd">        &gt;&gt;&gt; encoder = CategoricalEncoder()</span>
<span class="sd">        &gt;&gt;&gt; if not encoder.load_if_possible(encoding_file):</span>
<span class="sd">        ...     assert False  # We won&#39;t get here!</span>
<span class="sd">        &gt;&gt;&gt; encoder.decode_ndim(range(4))</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;Would load categorical encoding from </span><span class="si">{path}</span><span class="s2">, &quot;</span>
                <span class="s2">&quot;but file doesn&#39;t exist yet.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">SyntaxError</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;Would load categorical encoding from </span><span class="si">{path}</span><span class="s2">, &quot;</span>
                <span class="s2">&quot;and file existed but seems to be corrupted or otherwise couldn&#39;t load.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># If here, all good</span></div>

    <span class="k">def</span> <span class="nf">_get_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override this to provide any additional things to save</span>

<span class="sd">        Call super()._get_extras() to get the base extras</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;starting_index&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">starting_index</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;unk_label&quot;</span><span class="p">):</span>
            <span class="n">extras</span><span class="p">[</span><span class="s2">&quot;unk_label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unk_label</span>
        <span class="k">return</span> <span class="n">extras</span>

    <span class="k">def</span> <span class="nf">_set_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extras</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override this to e.g. load any extras needed</span>

<span class="sd">        Call super()._set_extras(extras) to set the base extras</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;unk_label&quot;</span> <span class="ow">in</span> <span class="n">extras</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unk_label</span> <span class="o">=</span> <span class="n">extras</span><span class="p">[</span><span class="s2">&quot;unk_label&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">starting_index</span> <span class="o">=</span> <span class="n">extras</span><span class="p">[</span><span class="s2">&quot;starting_index&quot;</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_save_literal</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">lab2ind</span><span class="p">,</span> <span class="n">extras</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save which is compatible with _load_literal&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">lab2ind</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="nb">repr</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">CategoricalEncoder</span><span class="o">.</span><span class="n">VALUE_SEPARATOR</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">CategoricalEncoder</span><span class="o">.</span><span class="n">EXTRAS_SEPARATOR</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">extras</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">CategoricalEncoder</span><span class="o">.</span><span class="n">VALUE_SEPARATOR</span>
                    <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_load_literal</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load which supports Python literals as keys.</span>

<span class="sd">        This is considered safe for user input, as well (unlike e.g. pickle).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lab2ind</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ind2lab</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># Load the label to index mapping (until EXTRAS_SEPARATOR)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="n">CategoricalEncoder</span><span class="o">.</span><span class="n">EXTRAS_SEPARATOR</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">literal</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                    <span class="n">CategoricalEncoder</span><span class="o">.</span><span class="n">VALUE_SEPARATOR</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
                <span class="n">lab2ind</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
                <span class="n">ind2lab</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
            <span class="c1"># Load the extras:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">literal_key</span><span class="p">,</span> <span class="n">literal_value</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                    <span class="n">CategoricalEncoder</span><span class="o">.</span><span class="n">VALUE_SEPARATOR</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">literal_key</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">literal_value</span><span class="p">)</span>
                <span class="n">extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">lab2ind</span><span class="p">,</span> <span class="n">ind2lab</span><span class="p">,</span> <span class="n">extras</span></div>


<div class="viewcode-block" id="TextEncoder"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder">[docs]</a><span class="k">class</span> <span class="nc">TextEncoder</span><span class="p">(</span><span class="n">CategoricalEncoder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;CategoricalEncoder subclass which offers specific methods for encoding text and handle</span>
<span class="sd">    special tokens for training of sequence to sequence models.</span>
<span class="sd">    In detail, aside special &lt;unk&gt; token already present in CategoricalEncoder</span>
<span class="sd">    for handling out-of-vocab tokens here special methods to handle</span>
<span class="sd">    &lt;bos&gt; beginning of sequence and &lt;eos&gt; tokens are defined.</span>

<span class="sd">    Note: update_from_iterable and update_from_didataset here have as default</span>
<span class="sd">    sequence_input=True because it is assumed that this encoder is used on</span>
<span class="sd">    iterables of strings: e.g.</span>

<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.encoder import TextEncoder</span>
<span class="sd">    &gt;&gt;&gt; dataset = [[&quot;encode&quot;, &quot;this&quot;, &quot;textencoder&quot;], [&quot;foo&quot;, &quot;bar&quot;]]</span>
<span class="sd">    &gt;&gt;&gt; encoder = TextEncoder()</span>
<span class="sd">    &gt;&gt;&gt; encoder.update_from_iterable(dataset)</span>
<span class="sd">    &gt;&gt;&gt; encoder.encode_label(&quot;this&quot;)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; encoder.add_unk()</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; encoder.encode_sequence([&quot;this&quot;, &quot;out-of-vocab&quot;])</span>
<span class="sd">    [1, 5]</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    Two methods can be used to add &lt;bos&gt; and &lt;eos&gt; to the internal dicts:</span>
<span class="sd">    insert_bos_eos, add_bos_eos.</span>

<span class="sd">    &gt;&gt;&gt; encoder.add_bos_eos()</span>
<span class="sd">    &gt;&gt;&gt; encoder.lab2ind[encoder.eos_label]</span>
<span class="sd">    7</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    add_bos_eos adds the special tokens at the end of the dict indexes</span>
<span class="sd">    &gt;&gt;&gt; encoder = TextEncoder()</span>
<span class="sd">    &gt;&gt;&gt; encoder.update_from_iterable(dataset)</span>
<span class="sd">    &gt;&gt;&gt; encoder.insert_bos_eos(bos_index=0, eos_index=1)</span>
<span class="sd">    &gt;&gt;&gt; encoder.lab2ind[encoder.eos_label]</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    insert_bos_eos allows to specify whose index will correspond to each of them.</span>
<span class="sd">    Note that you can also specify the same integer encoding for both.</span>

<span class="sd">    Four methods can be used to prepend &lt;bos&gt; and append &lt;eos&gt;.</span>
<span class="sd">    prepend_bos_label and append_eos_label add respectively the &lt;bos&gt; and &lt;eos&gt;</span>
<span class="sd">    string tokens to the input sequence</span>

<span class="sd">    &gt;&gt;&gt; words = [&quot;foo&quot;, &quot;bar&quot;]</span>
<span class="sd">    &gt;&gt;&gt; encoder.prepend_bos_label(words)</span>
<span class="sd">    [&#39;&lt;bos&gt;&#39;, &#39;foo&#39;, &#39;bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; encoder.append_eos_label(words)</span>
<span class="sd">    [&#39;foo&#39;, &#39;bar&#39;, &#39;&lt;eos&gt;&#39;]</span>

<span class="sd">    prepend_bos_index and append_eos_index add respectively the &lt;bos&gt; and &lt;eos&gt;</span>
<span class="sd">    indexes to the input encoded sequence.</span>

<span class="sd">    &gt;&gt;&gt; words = [&quot;foo&quot;, &quot;bar&quot;]</span>
<span class="sd">    &gt;&gt;&gt; encoded = encoder.encode_sequence(words)</span>
<span class="sd">    &gt;&gt;&gt; encoder.prepend_bos_index(encoded)</span>
<span class="sd">    [0, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; encoder.append_eos_index(encoded)</span>
<span class="sd">    [3, 4, 1]</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TextEncoder.handle_special_labels"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.handle_special_labels">[docs]</a>    <span class="k">def</span> <span class="nf">handle_special_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">special_labels</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">handle_special_labels</span><span class="p">(</span><span class="n">special_labels</span><span class="p">)</span>
        <span class="c1"># NOTE: bos_label and eos_label are not necessarily set at all!</span>
        <span class="c1"># This is because None is a suitable value.</span>
        <span class="c1"># So the test is: hasattr(self, &quot;bos_label&quot;)</span>
        <span class="c1"># rather than self.bos_label is not None</span>
        <span class="c1"># Same thing with unk, see base class.</span>
        <span class="k">if</span> <span class="s2">&quot;bos_label&quot;</span> <span class="ow">in</span> <span class="n">special_labels</span> <span class="ow">and</span> <span class="s2">&quot;eos_label&quot;</span> <span class="ow">in</span> <span class="n">special_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert_bos_eos</span><span class="p">(</span>
                <span class="n">special_labels</span><span class="p">[</span><span class="s2">&quot;bos_label&quot;</span><span class="p">],</span> <span class="n">special_labels</span><span class="p">[</span><span class="s2">&quot;eos_label&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;bos_label&quot;</span> <span class="ow">in</span> <span class="n">special_labels</span> <span class="ow">or</span> <span class="s2">&quot;eos_label&quot;</span> <span class="ow">in</span> <span class="n">special_labels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only BOS or EOS specified. Need both for init.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TextEncoder.update_from_iterable"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.update_from_iterable">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">sequence_input</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change default for sequence_input to True.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update_from_iterable</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">sequence_input</span><span class="p">)</span></div>

<div class="viewcode-block" id="TextEncoder.update_from_didataset"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.update_from_didataset">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_didataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">didataset</span><span class="p">,</span> <span class="n">output_key</span><span class="p">,</span> <span class="n">sequence_input</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change default for sequence_input to True.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update_from_didataset</span><span class="p">(</span>
            <span class="n">didataset</span><span class="p">,</span> <span class="n">output_key</span><span class="p">,</span> <span class="n">sequence_input</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TextEncoder.limited_labelset_from_iterable"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.limited_labelset_from_iterable">[docs]</a>    <span class="k">def</span> <span class="nf">limited_labelset_from_iterable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">sequence_input</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_most_common</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change default for sequence_input to True.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">limited_labelset_from_iterable</span><span class="p">(</span>
            <span class="n">iterable</span><span class="p">,</span> <span class="n">sequence_input</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_most_common</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TextEncoder.add_bos_eos"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.add_bos_eos">[docs]</a>    <span class="k">def</span> <span class="nf">add_bos_eos</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">bos_label</span><span class="o">=</span><span class="n">DEFAULT_BOS</span><span class="p">,</span> <span class="n">eos_label</span><span class="o">=</span><span class="n">DEFAULT_EOS</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add sentence boundary markers in the label set.</span>

<span class="sd">        If the beginning-of-sentence and end-of-sentence markers</span>
<span class="sd">        are the same, will just use one sentence-boundary label.</span>

<span class="sd">        This method adds to the end of the index, rather than at the beginning,</span>
<span class="sd">        like insert_bos_eos.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        bos_label : hashable</span>
<span class="sd">            Beginning-of-sentence label, any label.</span>
<span class="sd">        eos_label : hashable</span>
<span class="sd">            End-of-sentence label, any label. If set to the same label as</span>
<span class="sd">            bos_label, will just use one sentence-boundary label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bos_label</span> <span class="o">==</span> <span class="n">eos_label</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;BOS and EOS labels are the same so using just one sentence &quot;</span>
                <span class="s2">&quot;boundary label&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span><span class="p">(</span><span class="n">bos_label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span><span class="p">(</span><span class="n">bos_label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span><span class="p">(</span><span class="n">eos_label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bos_label</span> <span class="o">=</span> <span class="n">bos_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eos_label</span> <span class="o">=</span> <span class="n">eos_label</span></div>

<div class="viewcode-block" id="TextEncoder.insert_bos_eos"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.insert_bos_eos">[docs]</a>    <span class="k">def</span> <span class="nf">insert_bos_eos</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bos_label</span><span class="o">=</span><span class="n">DEFAULT_BOS</span><span class="p">,</span>
        <span class="n">eos_label</span><span class="o">=</span><span class="n">DEFAULT_EOS</span><span class="p">,</span>
        <span class="n">bos_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">eos_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert sentence boundary markers in the label set.</span>

<span class="sd">        If the beginning-of-sentence and end-of-sentence markers</span>
<span class="sd">        are the same, will just use one sentence-boundary label.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        bos_label : hashable</span>
<span class="sd">            Beginning-of-sentence label, any label</span>
<span class="sd">        eos_label : hashable</span>
<span class="sd">            End-of-sentence label, any label. If set to the same label as</span>
<span class="sd">            bos_label, will just use one sentence-boundary label.</span>
<span class="sd">        bos_index : int</span>
<span class="sd">            Where to insert bos_label. eos_index = bos_index + 1</span>
<span class="sd">        bos_index : optional, int</span>
<span class="sd">            Where to insert eos_label. Default: eos_index = bos_index + 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bos_label</span> <span class="o">==</span> <span class="n">eos_label</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;BOS and EOS labels are the same so using just one sentence &quot;</span>
                <span class="s2">&quot;boundary label&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert_label</span><span class="p">(</span><span class="n">bos_label</span><span class="p">,</span> <span class="n">bos_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert_label</span><span class="p">(</span><span class="n">bos_label</span><span class="p">,</span> <span class="n">bos_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">eos_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;EOS label not specified, using BOS label + 1&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insert_label</span><span class="p">(</span><span class="n">eos_label</span><span class="p">,</span> <span class="n">bos_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insert_label</span><span class="p">(</span><span class="n">eos_label</span><span class="p">,</span> <span class="n">eos_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bos_label</span> <span class="o">=</span> <span class="n">bos_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eos_label</span> <span class="o">=</span> <span class="n">eos_label</span></div>

<div class="viewcode-block" id="TextEncoder.get_bos_index"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.get_bos_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_bos_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index to which blank encodes&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;bos_label&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;BOS label is not set!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bos_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="TextEncoder.get_eos_index"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.get_eos_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_eos_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index to which blank encodes&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;eos_label&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;EOS label is not set!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eos_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="TextEncoder.prepend_bos_label"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.prepend_bos_label">[docs]</a>    <span class="k">def</span> <span class="nf">prepend_bos_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list version of x, with BOS prepended&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;bos_label&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;BOS label has not been added to label set!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bos_label</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="TextEncoder.prepend_bos_index"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.prepend_bos_index">[docs]</a>    <span class="k">def</span> <span class="nf">prepend_bos_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list version of x, with BOS index prepended.</span>
<span class="sd">        If the input is a tensor, a tensor is returned.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;bos_label&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;BOS label has not been added to label set!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">bos_ind</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bos_label</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">bos_ind</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bos_label</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="TextEncoder.append_eos_label"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.append_eos_label">[docs]</a>    <span class="k">def</span> <span class="nf">append_eos_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list version of x, with EOS appended.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;eos_label&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;EOS label has not been added to label set!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eos_label</span><span class="p">]</span></div>

<div class="viewcode-block" id="TextEncoder.append_eos_index"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.TextEncoder.append_eos_index">[docs]</a>    <span class="k">def</span> <span class="nf">append_eos_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list version of x, with EOS index appended.</span>
<span class="sd">        If the input is a tensor, a tensor is returned.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;eos_label&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;EOS label has not been added to label set!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">eos_ind</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eos_label</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">eos_ind</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eos_label</span><span class="p">]]</span></div>

    <span class="k">def</span> <span class="nf">_get_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_extras</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;bos_label&quot;</span><span class="p">):</span>
            <span class="n">extras</span><span class="p">[</span><span class="s2">&quot;bos_label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bos_label</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;eos_label&quot;</span><span class="p">):</span>
            <span class="n">extras</span><span class="p">[</span><span class="s2">&quot;eos_label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eos_label</span>
        <span class="k">return</span> <span class="n">extras</span>

    <span class="k">def</span> <span class="nf">_set_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extras</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_extras</span><span class="p">(</span><span class="n">extras</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;bos_label&quot;</span> <span class="ow">in</span> <span class="n">extras</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bos_label</span> <span class="o">=</span> <span class="n">extras</span><span class="p">[</span><span class="s2">&quot;bos_label&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;eos_label&quot;</span> <span class="ow">in</span> <span class="n">extras</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eos_label</span> <span class="o">=</span> <span class="n">extras</span><span class="p">[</span><span class="s2">&quot;eos_label&quot;</span><span class="p">]</span></div>


<div class="viewcode-block" id="CTCTextEncoder"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CTCTextEncoder">[docs]</a><span class="k">class</span> <span class="nc">CTCTextEncoder</span><span class="p">(</span><span class="n">TextEncoder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Subclass of TextEncoder which also provides methods to handle CTC blank token.</span>

<span class="sd">    add_blank and insert_blank can be used to add &lt;blank&gt; special token to the encoder</span>
<span class="sd">    state.</span>

<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.encoder import CTCTextEncoder</span>
<span class="sd">    &gt;&gt;&gt; chars = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>
<span class="sd">    &gt;&gt;&gt; encoder = CTCTextEncoder()</span>
<span class="sd">    &gt;&gt;&gt; encoder.update_from_iterable(chars)</span>
<span class="sd">    &gt;&gt;&gt; encoder.add_blank()</span>
<span class="sd">    &gt;&gt;&gt; encoder.encode_sequence(chars)</span>
<span class="sd">    [0, 1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; encoder.get_blank_index()</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; encoder.decode_ndim([0, 1, 2, 3, 4])</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;&lt;blank&gt;&#39;]</span>

<span class="sd">    collapse_labels and collapse_indices_ndim can be used to apply CTC collapsing</span>
<span class="sd">    rules:</span>
<span class="sd">    &gt;&gt;&gt; encoder.collapse_labels([&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">    &gt;&gt;&gt; encoder.collapse_indices_ndim([4, 4, 0, 1, 2, 3, 4, 4]) # 4 is &lt;blank&gt;</span>
<span class="sd">    [0, 1, 2, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CTCTextEncoder.handle_special_labels"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CTCTextEncoder.handle_special_labels">[docs]</a>    <span class="k">def</span> <span class="nf">handle_special_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">special_labels</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">handle_special_labels</span><span class="p">(</span><span class="n">special_labels</span><span class="p">)</span>
        <span class="c1"># NOTE: blank_label is not necessarily set at all!</span>
        <span class="c1"># This is because None is a suitable value.</span>
        <span class="c1"># So the test is: hasattr(self, &quot;blank_label&quot;)</span>
        <span class="c1"># rather than self.blank_label is not None</span>
        <span class="c1"># Same thing with unk, see base class.</span>
        <span class="k">if</span> <span class="s2">&quot;blank_label&quot;</span> <span class="ow">in</span> <span class="n">special_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert_blank</span><span class="p">(</span><span class="n">special_labels</span><span class="p">[</span><span class="s2">&quot;blank_label&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="CTCTextEncoder.add_blank"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CTCTextEncoder.add_blank">[docs]</a>    <span class="k">def</span> <span class="nf">add_blank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blank_label</span><span class="o">=</span><span class="n">DEFAULT_BLANK</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add blank symbol to labelset.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span><span class="p">(</span><span class="n">blank_label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blank_label</span> <span class="o">=</span> <span class="n">blank_label</span></div>

<div class="viewcode-block" id="CTCTextEncoder.insert_blank"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CTCTextEncoder.insert_blank">[docs]</a>    <span class="k">def</span> <span class="nf">insert_blank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blank_label</span><span class="o">=</span><span class="n">DEFAULT_BLANK</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert blank symbol at a given labelset.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert_label</span><span class="p">(</span><span class="n">blank_label</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blank_label</span> <span class="o">=</span> <span class="n">blank_label</span></div>

<div class="viewcode-block" id="CTCTextEncoder.get_blank_index"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CTCTextEncoder.get_blank_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_blank_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index to which blank encodes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;blank_label&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Blank label is not set!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blank_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="CTCTextEncoder.collapse_labels"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CTCTextEncoder.collapse_labels">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">merge_repeats</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies the CTC collapsing rules on one label sequence.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        x : iterable</span>
<span class="sd">            Label sequence on which to operate.</span>
<span class="sd">        merge_repeats : bool</span>
<span class="sd">            Whether to merge repeated labels before removing blanks.</span>
<span class="sd">            In the basic CTC label topology, repeated labels are merged.</span>
<span class="sd">            However, in RNN-T, they are not.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of labels with collapsing rules applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This cannot work on arbitrary &quot;ndim&quot;, because strings can be</span>
        <span class="c1"># infinitely iterated. Iterating &quot;a&quot; produces &quot;a&quot; over and over again.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;blank_label&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Blank label has not been added&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">merge_repeats</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">label</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">label</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="n">label</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_label</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_label</span><span class="p">]</span></div>

<div class="viewcode-block" id="CTCTextEncoder.collapse_indices_ndim"><a class="viewcode-back" href="../../../speechbrain.dataio.encoder.html#speechbrain.dataio.encoder.CTCTextEncoder.collapse_indices_ndim">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_indices_ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">merge_repeats</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies the CTC collapsing rules on arbitrarily label sequence.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        x : iterable</span>
<span class="sd">            Label sequence on which to operate.</span>
<span class="sd">        merge_repeats : bool</span>
<span class="sd">            Whether to merge repeated labels before removing blanks.</span>
<span class="sd">            In the basic CTC label topology, repeated labels are merged.</span>
<span class="sd">            However, in RNN-T, they are not.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            List of labels with collapsing rules applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;blank_label&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Blank label has not been added&quot;</span><span class="p">)</span>
        <span class="c1"># Recursively operates on the different dimensions.</span>
        <span class="n">collapsed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">subtensor</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">collapsed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">collapse_indices_ndim</span><span class="p">(</span><span class="n">subtensor</span><span class="p">,</span> <span class="n">merge_repeats</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># Not an iterable at next level!</span>
                <span class="c1"># So we should rather operate on this dimension.</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># For-else: only enter else if NO break.</span>
            <span class="k">return</span> <span class="n">collapsed</span>
        <span class="c1"># We get here if we DID break:</span>
        <span class="n">blank_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab2ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">blank_label</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">merge_repeats</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">index</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">blank_index</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">x</span> <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">blank_index</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_get_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_extras</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;blank_label&quot;</span><span class="p">):</span>
            <span class="n">extras</span><span class="p">[</span><span class="s2">&quot;blank_label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blank_label</span>
        <span class="k">return</span> <span class="n">extras</span>

    <span class="k">def</span> <span class="nf">_set_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extras</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_extras</span><span class="p">(</span><span class="n">extras</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;blank_label&quot;</span> <span class="ow">in</span> <span class="n">extras</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blank_label</span> <span class="o">=</span> <span class="n">extras</span><span class="p">[</span><span class="s2">&quot;blank_label&quot;</span><span class="p">]</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, SpeechBrain

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>